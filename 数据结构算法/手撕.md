# 手撕

## memcpy

> memcpy函数是c和c++使用的内存拷贝函数，函数原型是：
>
> ```c++
> void *memcpy(void*dest, const void *src, size_t n);
> ```
>
> 表示由src指向地址为起始地址的连续n个字节的数据复制到以dest指向地址为起始地址的空间内。
>
> 与strcpy相比，memcpy并不是遇到'\0'就结束，而是一定会拷贝完n个字节。

注意事项：对于地址重叠的情况，上述函数的行为是未定义的，因此要考虑到此问题

要点：void*类型的指针不能运算，必须强转

必须要考虑内存重叠问题(画个图自然就明白了！)

**参数说明**

str1 —— 指向用于存储复制内容的内存起始地址，函数调用时类型强制转换为 void* 指针
str2 —— 指向要复制的数据源的内存起始地址，函数调用时类型强制转换为 void* 指针
n    —— 要被复制的内存长度（字节数）

**关于 void* 指针**
  void* 指针，即不定类型指针。C 语言中指针仅占 4 个字节，即存储了一个内存地址，因此编译器在编译指针时必须知道它的类型（即 * 号前的部分），才能决定读取数据的长度。如 char* 指针，即 char 类型指针，编译器会从它指向的内存地址起只读取 1 个字节进行编译；而对于 int* 指针，即 int 类型指针，编译器则会从它指向的内存地址起读取 4 个字节。
  在 C 语言中 void 一般表示 “空”、“无” 的意思，因此，void* 指针即为 “无类型指针”，正式称呼为 “不定类型指针”。大家也可以将其理解为 C 语言中指针的默认类型。因为不知道指针类型，编译器无法直接对 void* 指针操作，程序员在使用 void* 指针时必须将其转换为其他类型的指针来使用，具体用法可以看下面的代码示例。
  至于为什么 memcpy 参数和返回值要用 void* 指针，个人理解一方面是为了标准化，规范化，提高普适性，统一输入输出接口；另一方面也是防止程序员忘记进行类型转换吧，毕竟返回的 void* 不转类型就会报错。

**关于 size_t 类型**
  简单理解，C语言中，它底层就是一个 unsigned int 。使用 size_t 主要还是为了提高代码的可移植性、有效性或者可读性。在不同的语言中，不同的平台上，size_t 的定义也许不一样，但这都不是当前程序员关心的问题，我只需要开放接口给后来人就行了。



![memcpy](https://img-blog.csdnimg.cn/96221cc3d71c4872bd146e95ce5e5aee.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATG91aXN0YXJr,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)

```c++
void * my_memcpy(void *dst, const void *src, size_t count){
	if(dst==nullptr||src==nullptr){
		return nullptr;
	}
    char* temp_dst=(char*)dst;
    char* temp_src=(char*)src;
    if(temp_dst>temp_src&&temp_dst<temp_src+count ){
        //有内存重叠的情况
       	temp_dst=temp_dst+count-1;
        temp_src=temp_src+count-1;
        while(count--){
            *temp_dst--=*temp_src--;
        }
    }else{
        //没有内存重叠的情况
         while(count--){
            *temp_dst++=*temp_src++;
        }
    }
    return (void *)dst;
}  
```

函数接口：
· 用两个 void* 指针接收目标内存地址和源内存地址，一个无符号整型接收内存拷贝长度
· 注意给源内存地址的形参加 const（加在数据类型左边，保护指向的内容），防止篡改原始数据
· 返回值类型也是 void* 指针（保证接口的通用性）
· 得到函数接口 void* memcpy(void* dst, const void* src, unsigned int count)
主体部分：
· 先定义返回值 void* ret = dst; return ret;（返回的是目标内存区域的首地址）
· 拷贝顺序就用简单的正序拷贝实现，即从头开始，逐字节拷贝 count 次
· 用 while 循环实现迭代操作，while ( count-- ) 正好可以跑 count 次
· 循环内部：先赋值，再偏移。（ void* 无法直接运算或解引用，需要先转换类型）
· 赋值操作：(char *)dst = *(char *)src;
· 偏移操作：dst = (char *)dst + 1; src = (char *)src + 1;

```
void* memcpy(void* dst, const void* src, unsigned int count)
{
    void* ret = dst;
    while ( count-- )
    {
        *(char *)dst = *(char *)src;
        dst = (char *)dst + 1;
        src = (char *)src + 1;
    }
    return ret;
}

```

第 1 行：函数接口必须不能错！尤其是 src 前必须加 const 修饰，进行保护。
第 3 行：先写返回值，即将目标内存地址保存下来用于返回。
第 4 行：循环条件，根据拷贝长度逐字节循环拷贝，必须用 count-- 不能 --count。
第 6 行：void* 指针每次使用时要先进行类型转换。
第 7-8 行：指针偏移操作，这也是为什么第 3 行要先写返回值。



## memmove

memmove 和 memcpy 的区别

* memmove 会检查内存重叠是否，但 memcpy 不会
* 若目标内存地址头部与源内存地址尾部重叠，正序拷贝时会破坏源内存数据
* 当源内存区域的尾部与目标内存区域的头部重叠时，memmove 会采用倒序拷贝的策略
* 即如下图所示，前两种情况 memmove 采用正序拷贝，第三种情况采用倒序拷贝

![memcpy_vs_memmove](https://img-blog.csdnimg.cn/0d80e75a8f47450eb297e1117d6a91f0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATG91aXN0YXJr,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)

一句话概括：检测内存是否重叠，无重叠则正序逐字节拷贝，重叠则倒序逐字节拷贝。

函数接口：
跟 memcpy 思路一样，`void* memmove(void* dst, const void* src, unsigned int count)`

内存重叠判断：

* 目标内存地址在源内存地址之前，可以正序拷贝：dst <= src
* 目标内存地址在源内存地址之后，但不重叠，可以正序拷贝：dst >= (char *)src + count
* 其他情况，采用倒序拷贝

主体部分：

* 正序拷贝的写法和 memcpy 相同
* 倒序拷贝分两步，先偏移两个指针 dst = (char *)dst + count - 1; src = (char *)src + count - 1;
* 然后和正序拷贝一样用一个 while 循环逐字节拷贝，区别在于指针移动方向不同

```c
void* memmove(void* dst, const void* src, unsigned int count)
{
    void* ret = dst;
    if ( dst <= src || dst >= (char *)src + count )
    {
        while (count--)
        {
            *(char *)dst = *(char *)src;
            dst = (char *)dst + 1;
            src = (char *)src + 1;
        }
    }
    else
    {
        dst = (char *)dst + count - 1;
        src = (char *)src + count - 1;
        while ( count-- )
        {
            *(char *)dst = *(char *)src;
            dst = (char *)dst - 1;
            src = (char *)src - 1;
        }
    }
    return ret;
}

```

- 第 4 行：内存重叠的检查条件必须不能写错！
- 其余手撕代码重点与 memcpy 相同



## strcat

```c
char* mystrcat(char* dst, char* src)
{
	char *res = dst;
	while (*dst != '\0') ++dst;
	while (*src != '\0')
	{
		*dst++ = *src++;
	}
	*dst = '\0';//添加结束符，不然后面有乱码！
	return res;
}
```



## strcmp

```c
int mystrcmp(char* str1, char* str2)
{
	while (*str1 == *str2 && *str1 != '\0')
	{
		++str1;
		++str2;
	}
	return *str1 - *str2;
}

```



## strcpy

strcpy和memcpy主要有以下3方面的区别。
1、复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。
2、复制的方法不同。strcpy不需要指定长度，它遇到被复制字符的串结束符"\0"才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度。
3、用途不同。通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy



除了边界条件需要检查以外，还有一个容易被忽视的地方即其返回值一定要是目标内存地址，以支持所谓的链式拷贝。即：

```
strcpy(dest3, strcpy(dest2, strcpy(dest1, src1)));
```



```c
char* strcpy(char* dst, char* src)//内存重叠
{
	assert((dst != NULL && src != NULL));
	char* ret = dst;
	int size = strlen(src) + 1;
	if (dst >= src && dst < src + size)//这个dst的内存在src的范围内，即出现可内存重叠
	{
		dst = dst + size - 1;
		src = src + size - 1;
		while (size--)
		{
			*dst-- = *src--;//将src的值从后向前赋值，赋给dst
		}
	}
	else
	{
		while (size--) //非自我赋值时候
		{
			*dst++ = *src++; 
		}
	}
	return ret;
}
```



## 实现 atoi

```
int` `atoi(``const` `char``* p);
```

- 容易疏忽的地方有如下几点：
- 小数点问题，如数字0.123和.123都是合法的；
- 正负号问题，如+123和-123；
- 考虑如何识别第一个非法字符问题，如123Z89，则应转换成应该123。
	我在面试掌门科技（无线***那一家）就遇到过这样的问题。



## 返回一个指定字节大小的内存，函数返回值代表成功与否

根据 malloc 或 new 的返回值或者异常进行代码编写

![image-20221025205005921](../../../.config/Typora/typora-user-images/image-20221025205005921.png)

## 大小写转化考虑异常



## 进制转换





## 大小端判断

端存储：字数据的高字节存储在低地址中

小端存储：字数据的低字节存储在低地址中

例如：32bit的数字0x12345678

**所以在Socket编程中，往往需要将操作系统所用的小端存储的IP地址转换为大端存储，这样才能进行网络传输**

小端模式中的存储方式为：

![img](https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.4.2/202102/1564134200013.png)

大端模式中的存储方式为：

![img](https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.4.2/202102/1564134220855.png)

了解了大小端存储的方式，如何在代码中进行判断呢？下面介绍两种判断方式：

**方式一：使用强制类型转换**-这种法子不错

```c++
#include <iostream>
using namespace std;
int main()
{
    int a = 0x1234;
    //由于int和char的长度不同，借助int型转换成char型，只会留下低地址的部分
    char c = (char)(a);
    if (c == 0x12)
        cout << "big endian" << endl;
    else if(c == 0x34)
        cout << "little endian" << endl;
}
```

**方式二：巧用union联合体**

```c++
#include <iostream>
using namespace std;
//union联合体的重叠式存储，endian联合体占用内存的空间为每个成员字节长度的最大值
union endian
{
    int a;
    char ch;
};
int main()
{
    endian value;
    value.a = 0x1234;
    //a和ch共用4字节的内存空间
    if (value.ch == 0x12)
        cout << "big endian"<<endl;
    else if (value.ch == 0x34)
        cout << "little endian"<<endl;
}
```



## LFU



## 有衰减机制的 LFU



## LRU

LRU(Least Recently Used) 即最近最少使用，属于典型的内存淘汰机制。

根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”，其思路如下图所示：

<img src="https://cdn.jsdelivr.net/gh/luogou/cloudimg/data/202203281451446.png" alt="img" style="zoom: 50%;float:left" />

该算法需要达到两个目的：①可以轻易的更新最新的访问数据。②轻易的找出最近最少未使用的数据。所以要用到哈希表+双向链表实现。利用map，获取key对应的value是O(1)，利用双向链表，实现新增和删除都是O(1)。

> 传统意义的LRU算法是为每一个Cache对象设置一个计数器，每次Cache命中则给计数器+1，而Cache用完，需要淘汰旧内容，放置新内容时，就查看所有的计数器，并将最少使用的内容替换掉。它的弊端很明显，如果Cache的数量少，问题不会很大， 但是如果Cache的空间过大，达到10W或者100W以上，一旦需要淘汰，则需要遍历所有计数器，其性能与资源消耗是巨大的。效率也就非常的慢了。双链表LRU的原理： 将Cache的所有位置都用双链表连接起来，当一个位置被命中之后，就将通过调整链表的指向，将该位置调整到链表头的位置，新加入的Cache直接加到链表头中。 这样，在多次进行Cache操作后，最近被命中的，就会被向链表头方向移动，而没有命中的，则向链表后面移动，链表尾则表示最近最少使用的Cache。当需要替换内容时候，链表的最后位置就是最少被命中的位置，我们只需要淘汰链表最后的部分即可。



LRU数据结构如下图：

<img src="https://cdn.jsdelivr.net/gh/luogou/cloudimg/data/202203281937301.jpeg" alt="HashLinkedList" style="zoom:67%;float:left" />

根据上图我们可以分析一下：

1. 如果我们每次默认从链表尾部添加元素，那么显然越靠尾部的元素就是最近使用的，越靠头部的元素就是最久未使用的。
2. 对于某一个 `key`，我们可以通过哈希表快速定位到链表中的节点，从而取得对应 `val`。
3. 链表显然是支持在任意位置快速插入和删除的，改改指针就行。只不过传统的链表无法按照索引快速访问某一个位置的元素，而这里借助哈希表，可以通过 `key` 快速映射到任意一个链表节点，然后进行插入和删除。

- 版本1：自己实现循环链表存储，没有用API

	```c++
	/********************不用API的版本*************************/
	/********************简单说一下思路*************************/
	//1.首先hash表用的是unordered_map来实现，用来查找key对应的node节点，所以hash表应该是[key,node]形式存储
	//2.LRUCache这个类实现双向链表的添加，删除，更新和遍历
	//3.同时这个类还要实现get和put两个功能
	//4.我这里用的是循环双向链表，因此查找链表尾端的元素为O(1)，正常的双向链表是O(n)
	//总结：最重要的就是hash表中的key对应的不是int而是一个node节点，这个要记住
	#include<unordered_map>
	#include<iostream>
	struct Node{
	    int key;
	    int value;
	    Node* pre;
	    Node* next;
	    Node(){}
	    Node(int k, int v):key(k), value(v), pre(nullptr), next(nullptr){}
	};
	
	class LRUCache{
	private:
	    //通过key可以找到位于链表中的节点
	    std::unordered_map<int, Node*> hash;
	    int capacity;
	    Node* head_node;
	public:
	    LRUCache(int cap){
	        capacity = cap;
	        head_node = new Node();
	        //初始化dummy_Node,next和pre都指向自己
	        head_node->next = head_node->pre = head_node;
	    }
	    //将新来的插入双向链表头部
	    void add_Node(Node* n);
	    //将某个节点拿出来重新插入头部
	    void update_Node(Node* n);
	    //移除链表中最后一个（最久未使用）
	    void pop_back();
	    //输出LRU结构
	    void show();
	    int get(int key);
	    void put(int key, int value);
	};
	
	//注意，该节点可能是新节点，也可能是已经存在的有重新入链表的节点
	void LRUCache::add_Node(Node* n){
	    //表示当前节点n就是dummy的next节点，不用加入
	    if(n->pre == head_node){
	        return;
	    }
	    //将节点n插入head_node后面
	    n->pre = head_node;
	    n->next = head_node->next;
	    head_node->next->pre = n;
	    head_node->next = n;
	}
	
	void LRUCache::update_Node(Node* n){
	    //表示当前节点n就是dummy的next节点，不用断掉
	    if(n->pre == head_node){
	        return;
	    }
	    n->next->pre = n->pre;
	    n->pre->next = n->next;
	    add_Node(n);
	}
	
	//弹出链表的最后一个，由于是循环链表，就是head_node->pre
	void LRUCache::pop_back(){
	    Node* tmp = head_node->pre;
	    head_node->pre = tmp->pre;
	    tmp->pre->next = head_node;
	    //删除unordered_map中的key
	    hash.erase(tmp->key);
	}
	
	void LRUCache::show(){
	    //链表中没有节点，退出
	    if(head_node->next = head_node){
	        return;
	    }
	    Node* tmp = head_node->next;
	    while(tmp->next != head_node){
	        std::cout<<"key:"<<tmp->key<<",vlaue:"<<tmp->value<<std::endl;
	    }
	}
	int LRUCache::get(int key){
	    auto it = hash.find(key);
	    if(it == hash.end()){
	        std::cout<<"there is no key"<<std::endl;
	        return -1;
	    }
	    //取出key对应的node节点
	    Node* node = it->second;
	    update_Node(node);
	    return node->value;
	
	}
	void LRUCache::put(int key, int value){
	    auto it = hash.find(key);
	    if(it == hash.end()){
	        Node* node = new Node(key, value);
	        add_Node(node);
	        hash.insert({key, node});
	        if(hash.size() > capacity){
	            
	            pop_back();
	        }
	    }else{
	        it->second->value = value;
	        update_Node(it->second);
	    }
	}
	```

	

- 版本2：使用deque，为什么使用deque说的很清楚

	```c++
	/****************注意unordered_map的插入************/
	
	#include <iostream>
	#include <deque>
	#include <unordered_map>
	#include <list>
	
	class LRUCache{
	private:
	    int capacity;
	    //1.之所以用deque不用list是因为移除尾部元素的时候，deque方便
	    //2.deque里面可以存储自定的node类型，也可以用pair表示，这里我用pair了
	    std::deque<std::pair<int, int>> my_deque;
	    //通过key找到对应key在deque中的位置
	    std::unordered_map<int, std::deque<std::pair<int, int>>::iterator> hash;
	public:
	    LRUCache(int cap):capacity(cap){}
	    int get(int key);
	    void put(int key, int value);
	};
	
	int LRUCache::get(int key){
	    if(hash.find(key) == hash.end()){
	        std::cout<<"there is no key"<<std::endl;
	        return -1;
	    }
	    std::pair<int, int> tmp = *hash[key];
	    my_deque.erase(hash[key]);
	    my_deque.push_front(tmp);
	    //更新hash表中对应key位于deque的位置
	    hash[key] = my_deque.begin();
	    return tmp.second;
	}
	
	void LRUCache::put(int key, int value){
	    if(hash.find(key) == hash.end()){
	        if(my_deque.size() >= capacity){
	            //把hash表中的抹除，然后删除deque中的
	            auto it = my_deque.back();
	            hash.erase(it.first);
	            my_deque.pop_back();
	            my_deque.push_front({key, value});
	            hash.insert({key, my_deque.begin()});
	        }else{
	            my_deque.push_front({key, value});
	            hash.insert({key, my_deque.begin()});
	        }
	    }else{
	        //更新就行
	        my_deque.erase(hash[key]);
	        my_deque.push_front({key, value});
	        //更新hash表中key的位置
	        hash[key] = my_deque.begin();
	    }
	}
	```

	

## 有衰减机制的 LRU



## KMP



## 实现 sqrt
