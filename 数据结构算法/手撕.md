# 手撕

## memcpy

> memcpy函数是c和c++使用的内存拷贝函数，函数原型是：
>
> ```c++
> void *memcpy(void*dest, const void *src, size_t n);
> ```
>
> 表示由src指向地址为起始地址的连续n个字节的数据复制到以dest指向地址为起始地址的空间内。
>
> 与strcpy相比，memcpy并不是遇到'\0'就结束，而是一定会拷贝完n个字节。

注意事项：对于地址重叠的情况，上述函数的行为是未定义的，因此要考虑到此问题

要点：void*类型的指针不能运算，必须强转

必须要考虑内存重叠问题(画个图自然就明白了！)

**参数说明**

str1 —— 指向用于存储复制内容的内存起始地址，函数调用时类型强制转换为 void*指针
str2 —— 指向要复制的数据源的内存起始地址，函数调用时类型强制转换为 void* 指针
n    —— 要被复制的内存长度（字节数）

**关于 void* 指针**
  void* 指针，即不定类型指针。C 语言中指针仅占 4 个字节，即存储了一个内存地址，因此编译器在编译指针时必须知道它的类型（即 *号前的部分），才能决定读取数据的长度。如 char* 指针，即 char 类型指针，编译器会从它指向的内存地址起只读取 1 个字节进行编译；而对于 int*指针，即 int 类型指针，编译器则会从它指向的内存地址起读取 4 个字节。
  在 C 语言中 void 一般表示 “空”、“无” 的意思，因此，void* 指针即为 “无类型指针”，正式称呼为 “不定类型指针”。大家也可以将其理解为 C 语言中指针的默认类型。因为不知道指针类型，编译器无法直接对 void*指针操作，程序员在使用 void* 指针时必须将其转换为其他类型的指针来使用，具体用法可以看下面的代码示例。
  至于为什么 memcpy 参数和返回值要用 void*指针，个人理解一方面是为了标准化，规范化，提高普适性，统一输入输出接口；另一方面也是防止程序员忘记进行类型转换吧，毕竟返回的 void* 不转类型就会报错。

**关于 size_t 类型**
  简单理解，C语言中，它底层就是一个 unsigned int 。使用 size_t 主要还是为了提高代码的可移植性、有效性或者可读性。在不同的语言中，不同的平台上，size_t 的定义也许不一样，但这都不是当前程序员关心的问题，我只需要开放接口给后来人就行了。

![memcpy](https://img-blog.csdnimg.cn/96221cc3d71c4872bd146e95ce5e5aee.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATG91aXN0YXJr,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)

```c++
void * my_memcpy(void *dst, const void *src, size_t count){
 if(dst==nullptr||src==nullptr){
  return nullptr;
 }
    char* temp_dst=(char*)dst;
    char* temp_src=(char*)src;
    if(temp_dst>temp_src&&temp_dst<temp_src+count ){
        //有内存重叠的情况
        temp_dst=temp_dst+count-1;
        temp_src=temp_src+count-1;
        while(count--){
            *temp_dst--=*temp_src--;
        }
    }else{
        //没有内存重叠的情况
         while(count--){
            *temp_dst++=*temp_src++;
        }
    }
    return (void *)dst;
}  
```

函数接口：
· 用两个 void*指针接收目标内存地址和源内存地址，一个无符号整型接收内存拷贝长度
· 注意给源内存地址的形参加 const（加在数据类型左边，保护指向的内容），防止篡改原始数据
· 返回值类型也是 void* 指针（保证接口的通用性）
· 得到函数接口 void*memcpy(void* dst, const void*src, unsigned int count)
主体部分：
· 先定义返回值 void* ret = dst; return ret;（返回的是目标内存区域的首地址）
· 拷贝顺序就用简单的正序拷贝实现，即从头开始，逐字节拷贝 count 次
· 用 while 循环实现迭代操作，while ( count-- ) 正好可以跑 count 次
· 循环内部：先赋值，再偏移。（ void*无法直接运算或解引用，需要先转换类型）
· 赋值操作：(char*)dst = *(char*)src;
· 偏移操作：dst = (char *)dst + 1; src = (char*)src + 1;

```
void* memcpy(void* dst, const void* src, unsigned int count)
{
    void* ret = dst;
    while ( count-- )
    {
        *(char *)dst = *(char *)src;
        dst = (char *)dst + 1;
        src = (char *)src + 1;
    }
    return ret;
}

```

第 1 行：函数接口必须不能错！尤其是 src 前必须加 const 修饰，进行保护。
第 3 行：先写返回值，即将目标内存地址保存下来用于返回。
第 4 行：循环条件，根据拷贝长度逐字节循环拷贝，必须用 count-- 不能 --count。
第 6 行：void* 指针每次使用时要先进行类型转换。
第 7-8 行：指针偏移操作，这也是为什么第 3 行要先写返回值。

## memmove

memmove 和 memcpy 的区别

* memmove 会检查内存重叠是否，但 memcpy 不会
* 若目标内存地址头部与源内存地址尾部重叠，正序拷贝时会破坏源内存数据
* 当源内存区域的尾部与目标内存区域的头部重叠时，memmove 会采用倒序拷贝的策略
* 即如下图所示，前两种情况 memmove 采用正序拷贝，第三种情况采用倒序拷贝

![memcpy_vs_memmove](https://img-blog.csdnimg.cn/0d80e75a8f47450eb297e1117d6a91f0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATG91aXN0YXJr,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)

一句话概括：检测内存是否重叠，无重叠则正序逐字节拷贝，重叠则倒序逐字节拷贝。

函数接口：
跟 memcpy 思路一样，`void* memmove(void* dst, const void* src, unsigned int count)`

内存重叠判断：

* 目标内存地址在源内存地址之前，可以正序拷贝：dst <= src
* 目标内存地址在源内存地址之后，但不重叠，可以正序拷贝：dst >= (char *)src + count
* 其他情况，采用倒序拷贝

主体部分：

* 正序拷贝的写法和 memcpy 相同
* 倒序拷贝分两步，先偏移两个指针 dst = (char *)dst + count - 1; src = (char*)src + count - 1;
* 然后和正序拷贝一样用一个 while 循环逐字节拷贝，区别在于指针移动方向不同

```c
void* memmove(void* dst, const void* src, unsigned int count)
{
    void* ret = dst;
    if ( dst <= src || dst >= (char *)src + count )
    {
        while (count--)
        {
            *(char *)dst = *(char *)src;
            dst = (char *)dst + 1;
            src = (char *)src + 1;
        }
    }
    else
    {
        dst = (char *)dst + count - 1;
        src = (char *)src + count - 1;
        while ( count-- )
        {
            *(char *)dst = *(char *)src;
            dst = (char *)dst - 1;
            src = (char *)src - 1;
        }
    }
    return ret;
}

```

* 第 4 行：内存重叠的检查条件必须不能写错！
* 其余手撕代码重点与 memcpy 相同

## strcat

```c
char* mystrcat(char* dst, char* src)
{
 char *res = dst;
 while (*dst != '\0') ++dst;
 while (*src != '\0')
 {
  *dst++ = *src++;
 }
 *dst = '\0';//添加结束符，不然后面有乱码！
 return res;
}
```

## strcmp

```c
int mystrcmp(char* str1, char* str2)
{
 while (*str1 == *str2 && *str1 != '\0')
 {
  ++str1;
  ++str2;
 }
 return *str1 - *str2;
}

```

## strcpy

strcpy和memcpy主要有以下3方面的区别。
1、复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。
2、复制的方法不同。strcpy不需要指定长度，它遇到被复制字符的串结束符"\0"才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度。
3、用途不同。通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy

除了边界条件需要检查以外，还有一个容易被忽视的地方即其返回值一定要是目标内存地址，以支持所谓的链式拷贝。即：

```
strcpy(dest3, strcpy(dest2, strcpy(dest1, src1)));
```

```c
char* strcpy(char* dst, char* src)//内存重叠
{
 assert((dst != NULL && src != NULL));
 char* ret = dst;
 int size = strlen(src) + 1;
 if (dst >= src && dst < src + size)//这个dst的内存在src的范围内，即出现可内存重叠
 {
  dst = dst + size - 1;
  src = src + size - 1;
  while (size--)
  {
   *dst-- = *src--;//将src的值从后向前赋值，赋给dst
  }
 }
 else
 {
  while (size--) //非自我赋值时候
  {
   *dst++ = *src++; 
  }
 }
 return ret;
}
```

## 实现char** strsplit(const chat* src, chat delim)

## 实现 atoi

#### [8. 字符串转换整数 (atoi)](https://leetcode-cn.com/problems/string-to-integer-atoi/)

请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。

函数 myAtoi(string s) 的算法如下：

* 读入字符串并丢弃无用的前导空格

* 检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。
* 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。
* 将前面步骤读入的这些数字转换为整数（即，"123" -> 123， "0032" -> 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。
* 如果整数数超过 32 位有符号整数范围 [−2^31,  2^31 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −2^31 的整数应该被固定为 −2^31 ，大于 2^31 − 1 的整数应该被固定为 2^31 − 1 。
* 返回整数作为最终结果。

注意：

本题中的空白字符只包括空格字符 ' ' 。
除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。

### C++ 并统一正负数解析

ps: 对于逼近溢出临界的判断，比较巧妙，需要仔细体会，只要大于7，我们一律返回临界值
如果是正数 2,147,483,648，此时已经溢出,我们返回INT_MAX(2,147,483,647)
如果是负数-2,147,483,648, 此时没有溢出, 返回INT_MIN(-2,147,483,648),实际是它本身

```c++
class Solution {
public:
    int myAtoi(string s) {
        int i = 0, sign = 1, tmp = 0;        //没有符号字符时sign是正数

        while(s[i] == ' ')  ++i;              //1.忽略前导空格

        if(s[i] == '+' || s[i] == '-')        //2.确定正负号
            sign = (s[i++] == '-') ? -1 : 1;  //s[i]为+的话sign依旧为1，为-的话sign为-1

        while(s[i] >= '0' && s[i] <= '9')     //3.检查输入是否合法
        {
            if(tmp > INT_MAX / 10 || (tmp == INT_MAX / 10 && s[i] - '0' > 7)) //4.是否溢出
                return sign == 1 ? INT_MAX : INT_MIN;
            tmp = tmp * 10 + (s[i++] - '0');  //5.不加括号有溢出风险
        }
        return tmp * sign;
    }
};
```

### C 风格

```c++
class Solution {
private:    
    int myAtoiC(const char* str) {
        // 忽略前导空格
        while (*str == ' ') {
            str++;
        }
        bool minus = false;
        if (*str == '-') minus = true;
        if(*str == '+' || *str == '-') {
            str++;
        }
        // 忽略前导0
        while(*str == '0') {
            str++;
        }
        int num = 0;
        while(*str >= '0' && *str <= '9') {
            // INT_MAX = 2147483647
            // 刚刚好的情况 numNew = numOld * 10 + (*str - '0') == INT_MAX ->  numOld == (INT_MAX - i) / 10;
            int i = *str - '0';
            if (!minus && (num == INT_MAX / 10 && i >= 7) || num > INT_MAX / 10) {
                return INT_MAX;
            } 
            // INT_MIN = -2147483648
            // numOld == (INT_MAX + i) / 10
            if (minus && (num == INT_MIN  / 10 && i >= 8) || num < INT_MIN / 10) {
                return INT_MIN;
            }

            if (!minus)
                num = num * 10 + i;
            else 
                num = num * 10 - i;

            str++;
        }
        return num;

    }
public:
    int myAtoi(string s) {
        return myAtoiC(s.c_str());
    }
};
```

### C风格改进

```c++
class Solution {
private:    
    int myAtoiC(const char* str) {
        // 忽略前导空格
        while (*str == ' ') str++;
        bool minus = false;
        if (*str == '-') minus = true;
        if(*str == '+' || *str == '-') { str++; }
        // 忽略前导0
        while(*str == '0') str++;
        int num = 0;
        while(*str >= '0' && *str <= '9') {
            int i = *str - '0';
            if (num == INT_MAX / 10 && i > 7 || num > INT_MAX / 10) {
                return minus ? INT_MIN : INT_MAX;
            } 
            num = num * 10 + i;
            str++;
        }
        return minus ? -num : num;
    }
public:
    int myAtoi(string s) {
        return myAtoiC(s.c_str());
    }
};
```

## 返回一个指定字节大小的内存，函数返回值代表成功与否

根据 malloc 或 new 的返回值或者异常进行代码编写

![image-20221025205005921](../../../.config/Typora/typora-user-images/image-20221025205005921.png)

## 大小写转化考虑异常

## 进制转换

## 大小端判断

端存储：字数据的高字节存储在低地址中

小端存储：字数据的低字节存储在低地址中

例如：32bit的数字0x12345678

**所以在Socket编程中，往往需要将操作系统所用的小端存储的IP地址转换为大端存储，这样才能进行网络传输**

小端模式中的存储方式为：

![img](https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.4.2/202102/1564134200013.png)

大端模式中的存储方式为：

![img](https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.4.2/202102/1564134220855.png)

了解了大小端存储的方式，如何在代码中进行判断呢？下面介绍两种判断方式：

**方式一：使用强制类型转换**-这种法子不错

```c++
#include <iostream>
using namespace std;
int main()
{
    int a = 0x1234;
    //由于int和char的长度不同，借助int型转换成char型，只会留下低地址的部分
    char c = (char)(a);
    if (c == 0x12)
        cout << "big endian" << endl;
    else if(c == 0x34)
        cout << "little endian" << endl;
}
```

**方式二：巧用union联合体**

```c++
#include <iostream>
using namespace std;
//union联合体的重叠式存储，endian联合体占用内存的空间为每个成员字节长度的最大值
union endian
{
    int a;
    char ch;
};
int main()
{
    endian value;
    value.a = 0x1234;
    //a和ch共用4字节的内存空间
    if (value.ch == 0x12)
        cout << "big endian"<<endl;
    else if (value.ch == 0x34)
        cout << "little endian"<<endl;
}
```

## LFU

### 有衰减机制的 LFU

## LRU

LRU(Least Recently Used) 即最近最少使用，属于典型的内存淘汰机制。

根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”，其思路如下图所示：

<img src="https://cdn.jsdelivr.net/gh/luogou/cloudimg/data/202203281451446.png" alt="img" style="zoom: 50%;float:left" />

该算法需要达到两个目的：①可以轻易的更新最新的访问数据。②轻易的找出最近最少未使用的数据。所以要用到哈希表+双向链表实现。利用map，获取key对应的value是O(1)，利用双向链表，实现新增和删除都是O(1)。

> 传统意义的LRU算法是为每一个Cache对象设置一个计数器，每次Cache命中则给计数器+1，而Cache用完，需要淘汰旧内容，放置新内容时，就查看所有的计数器，并将最少使用的内容替换掉。它的弊端很明显，如果Cache的数量少，问题不会很大， 但是如果Cache的空间过大，达到10W或者100W以上，一旦需要淘汰，则需要遍历所有计数器，其性能与资源消耗是巨大的。效率也就非常的慢了。双链表LRU的原理： 将Cache的所有位置都用双链表连接起来，当一个位置被命中之后，就将通过调整链表的指向，将该位置调整到链表头的位置，新加入的Cache直接加到链表头中。 这样，在多次进行Cache操作后，最近被命中的，就会被向链表头方向移动，而没有命中的，则向链表后面移动，链表尾则表示最近最少使用的Cache。当需要替换内容时候，链表的最后位置就是最少被命中的位置，我们只需要淘汰链表最后的部分即可。

LRU数据结构如下图：

<img src="https://cdn.jsdelivr.net/gh/luogou/cloudimg/data/202203281937301.jpeg" alt="HashLinkedList" style="zoom:67%;float:left" />

根据上图我们可以分析一下：

1. 如果我们每次默认从链表尾部添加元素，那么显然越靠尾部的元素就是最近使用的，越靠头部的元素就是最久未使用的。
2. 对于某一个 `key`，我们可以通过哈希表快速定位到链表中的节点，从而取得对应 `val`。
3. 链表显然是支持在任意位置快速插入和删除的，改改指针就行。只不过传统的链表无法按照索引快速访问某一个位置的元素，而这里借助哈希表，可以通过 `key` 快速映射到任意一个链表节点，然后进行插入和删除。

* 版本1：自己实现循环链表存储，没有用API

 ```c++
 /********************不用API的版本*************************/
 /********************简单说一下思路*************************/
 //1.首先hash表用的是unordered_map来实现，用来查找key对应的node节点，所以hash表应该是[key,node]形式存储
 //2.LRUCache这个类实现双向链表的添加，删除，更新和遍历
 //3.同时这个类还要实现get和put两个功能
 //4.我这里用的是循环双向链表，因此查找链表尾端的元素为O(1)，正常的双向链表是O(n)
 //总结：最重要的就是hash表中的key对应的不是int而是一个node节点，这个要记住
 #include<unordered_map>
 #include<iostream>
 struct Node{
     int key;
     int value;
     Node* pre;
     Node* next;
     Node(){}
     Node(int k, int v):key(k), value(v), pre(nullptr), next(nullptr){}
 };
 
 class LRUCache{
 private:
     //通过key可以找到位于链表中的节点
     std::unordered_map<int, Node*> hash;
     int capacity;
     Node* head_node;
 public:
     LRUCache(int cap){
         capacity = cap;
         head_node = new Node();
         //初始化dummy_Node,next和pre都指向自己
         head_node->next = head_node->pre = head_node;
     }
     //将新来的插入双向链表头部
     void add_Node(Node* n);
     //将某个节点拿出来重新插入头部
     void update_Node(Node* n);
     //移除链表中最后一个（最久未使用）
     void pop_back();
     //输出LRU结构
     void show();
     int get(int key);
     void put(int key, int value);
 };
 
 //注意，该节点可能是新节点，也可能是已经存在的有重新入链表的节点
 void LRUCache::add_Node(Node* n){
     //表示当前节点n就是dummy的next节点，不用加入
     if(n->pre == head_node){
         return;
     }
     //将节点n插入head_node后面
     n->pre = head_node;
     n->next = head_node->next;
     head_node->next->pre = n;
     head_node->next = n;
 }
 
 void LRUCache::update_Node(Node* n){
     //表示当前节点n就是dummy的next节点，不用断掉
     if(n->pre == head_node){
         return;
     }
     n->next->pre = n->pre;
     n->pre->next = n->next;
     add_Node(n);
 }
 
 //弹出链表的最后一个，由于是循环链表，就是head_node->pre
 void LRUCache::pop_back(){
     Node* tmp = head_node->pre;
     head_node->pre = tmp->pre;
     tmp->pre->next = head_node;
     //删除unordered_map中的key
     hash.erase(tmp->key);
 }
 
 void LRUCache::show(){
     //链表中没有节点，退出
     if(head_node->next = head_node){
         return;
     }
     Node* tmp = head_node->next;
     while(tmp->next != head_node){
         std::cout<<"key:"<<tmp->key<<",vlaue:"<<tmp->value<<std::endl;
     }
 }
 int LRUCache::get(int key){
     auto it = hash.find(key);
     if(it == hash.end()){
         std::cout<<"there is no key"<<std::endl;
         return -1;
     }
     //取出key对应的node节点
     Node* node = it->second;
     update_Node(node);
     return node->value;
 
 }
 void LRUCache::put(int key, int value){
     auto it = hash.find(key);
     if(it == hash.end()){
         Node* node = new Node(key, value);
         add_Node(node);
         hash.insert({key, node});
         if(hash.size() > capacity){
             
             pop_back();
         }
     }else{
         it->second->value = value;
         update_Node(it->second);
     }
 }
 ```

* 版本2：使用deque，为什么使用deque说的很清楚

 ```c++
 /****************注意unordered_map的插入************/
 
 #include <iostream>
 #include <deque>
 #include <unordered_map>
 #include <list>
 
 class LRUCache{
 private:
     int capacity;
     //1.之所以用deque不用list是因为移除尾部元素的时候，deque方便
     //2.deque里面可以存储自定的node类型，也可以用pair表示，这里我用pair了
     std::deque<std::pair<int, int>> my_deque;
     //通过key找到对应key在deque中的位置
     std::unordered_map<int, std::deque<std::pair<int, int>>::iterator> hash;
 public:
     LRUCache(int cap):capacity(cap){}
     int get(int key);
     void put(int key, int value);
 };
 
 int LRUCache::get(int key){
     if(hash.find(key) == hash.end()){
         std::cout<<"there is no key"<<std::endl;
         return -1;
     }
     std::pair<int, int> tmp = *hash[key];
     my_deque.erase(hash[key]);
     my_deque.push_front(tmp);
     //更新hash表中对应key位于deque的位置
     hash[key] = my_deque.begin();
     return tmp.second;
 }
 
 void LRUCache::put(int key, int value){
     if(hash.find(key) == hash.end()){
         if(my_deque.size() >= capacity){
             //把hash表中的抹除，然后删除deque中的
             auto it = my_deque.back();
             hash.erase(it.first);
             my_deque.pop_back();
             my_deque.push_front({key, value});
             hash.insert({key, my_deque.begin()});
         }else{
             my_deque.push_front({key, value});
             hash.insert({key, my_deque.begin()});
         }
     }else{
         //更新就行
         my_deque.erase(hash[key]);
         my_deque.push_front({key, value});
         //更新hash表中key的位置
         hash[key] = my_deque.begin();
     }
 }
 ```

### 有衰减机制的 LRU

### LRU 应用场景

## KMP

## 实现 sqrt

[69. x 的平方根](https://leetcode-cn.com/problems/sqrtx/)

### 方法一：袖珍计算器算法

「袖珍计算器算法」是一种用指数函数 exp 和对数函数 ln 代替平方根函数的方法。我们通过有限的可以使用的数学函数，得到我们想要计算的结果。

我们将 $\sqrt{x} $ 写成幂的形式 $x^{1/2} $

 ，再使用自然对数 e 进行换底，即可得到

$\sqrt{x} = x^{1/2} = (e ^ {\ln x})^{1/2} = e^{\frac{1}{2} \ln x}$

**注意：** 由于计算机无法存储浮点数的精确值,有误差.例如当 x=2147395600 时，$e^{\frac{1}{2} \ln x} $的计算结果与正确值 46340相差 $10^{-11} $ ，这样在对结果取整数部分时，会得到 46339 这个错误的结果。

因此在得到结果的整数部分ans 后，我们应当找出ans 与 ans+1 中哪一个是真正的答案。

```c++
class Solution {
public:
    int mySqrt(int x) {
        if (x == 0) {
            return 0;
        }
        int ans = exp(0.5 * log(x));
        return ((long long)(ans + 1) * (ans + 1) <= x ? ans + 1 : ans);
    }
};
```

### 方法二：二分查找

由于 x 平方根的整数部分 ans 是满足 $k^2 \leq x$的最大 k 值，因此我们可以对 k 进行二分查找，从而得到答案。

二分查找的下界为 0，上界可以粗略地设定为 x。在二分查找的每一步中，我们只需要比较中间元素 mid 的平方与 x 的大小关系，并通过比较的结果调整上下界的范围。由于我们所有的运算都是整数运算，不会存在误差。

```c++
int mySqrt(int x) {
        // 试一试二分查找是否能够解决啦啦啦
        // k * k <= x 找最大的k
        int left = 0, right = x;
        // [left, right]
        int ans = 0;
        while (left <= right) {
            int mid = left + (right - left >> 1);
            if (static_cast<long long>(mid) * mid > x) {
                right = mid - 1;
            } else {
                ans = mid;
                left = mid + 1;
            } 
        }
        return ans;
    }
```

### 方法三：牛顿迭代

牛顿迭代法是一种可以用来快速求解函数**零点**的方法。

为了叙述方便，我们用 C 表示待求出平方根的那个整数。

显然，C 的平方根就是函数$y = f(x) = x^2 - C$ 的零点。

![fig1](https://assets.leetcode-cn.com/solution-static/69/69_fig1.png)

算法

我们选择x0 = C作为初始值。

在每一步迭代中，我们通过当前的交点xi,找到图像上Pi (xi, xi^2^ - C)

然后作切线，斜率f^'^'(xi) = 2xi, 经过点Pi 与x轴相交。

切线方程 y = 2xi x - (xi^2^ + C), y = 0即新的交点

Pi+1 ( 1/2 (xi + C / xi) ,0)

**迭代到何时才算结束**？

每一次迭代后，我们都会距离零点更进一步，所以当相邻两次迭代得到的交点非常接近时，我们就可以断定。一般来说，可以判断相邻两次迭代的结果的差值是否小于一个极小的非负数 $\epsilon$，其中 $\epsilon$ 一般可以取 $10^{-6}$

```c++
class Solution {
public:
    int mySqrt(int x) {
        if (x == 0) {
            return 0;
        }

        double C = x, x0 = x;
        while (true) {
            double xi = 0.5 * (x0 + C / x0);
            if (fabs(x0 - xi) < 1e-7) {
                break;
            }
            x0 = xi;
        }
        return int(x0);
    }
};
```

## 建立二叉树

## 实现 string

```c++
class String {
private:
 char* m_data;
    int m_size;
public:
    // 默认构造函数
 String(const char* str = nullptr);
    // 拷贝构造函数
 String(const String& other);
 String(String&& other);
    // 字符串赋值函数
 String& operator=(const String& other);
 String& operator=(String&& other);
    // 析构函数
 ~String();
 int length() { return strlen(data); }
 /*
 其它功能
 */
};
// 构造函数
String::String(const char* str) {
    // 这一步判断是否为nullptr加分点
 if (str == nullptr) {
  m_data = new char[1];
        m_data[0] = '\0';
        m_size = 0;
 }
 else {
  m_size = strlen(str);
        m_data = new char[m_size + 1];
        strcpy(m_data, str);
 }
}
// 拷贝构造函数, 得分点：输入参数是const
String::String(const String& other) {
 m_size = other.m_size;
    m_data = new char[m_size + 1];
    strcpy(m_data, other.m_data);
}
// 移动构造函数
String::String(String&& other) {
 m_data = other.m_data;
 other.m_data = nullptr;
}
// 赋值，注意形参const ,注意返回引用
String& String::operator=(const String& other) {
 // 得分点1：检查自赋值
    if (this == &other)
        return *this;
    // 得分点2：释放原有的内存资源
    delete[] m_data;
    m_size = other.m_size;
    m_data = new char[m_size + 1];
    strcpy(m_data, other.m_data);
    return *this; // 返回本对象的引用
}
// 移动赋值
String& String::operator=(String&& other) {
 if (this == &other) 
        return *this;
 delete[] m_data;
 m_data = other.m_data;
 other.m_data = nullptr;
 return *this;
}
// 析构
String::~String() { 
 delete[] m_data;
}
```

需要注意的点：

delete[] nullptr会发生什么问题？试一试:一切正常

```c++
int main()
{
    int* p = new int[1];
    delete[] p;
    p = nullptr;
    delete[] p;
    return 0;
}
```

## 哈希表

### 手撕哈希表 C语言

```cpp
#include<stdio.h>
#include<stdlib.h>

#define SUCCESS 1
#define UNSUCCESS 0
#define OVERFLOW -1
#define OK 1
#define ERROR -1
#define MAXNUM 9999  // 用于初始化哈希表的记录 key

typedef int Status;
typedef int KeyType;

// 哈希表中的记录类型
typedef struct {
 KeyType key;
}RcdType;

// 哈希表类型
typedef struct {
 RcdType *rcd;
 int size;
 int count;
 int *tag;
}HashTable;

// 哈希表每次重建增长后的大小
int hashsize[] = { 11, 31, 61, 127, 251, 503 };
int index = 0;

// 初始哈希表
Status InitHashTable(HashTable &H, int size) {
 int i;
 H.rcd = (RcdType *)malloc(sizeof(RcdType)*size);
 H.tag = (int *)malloc(sizeof(int)*size);
 if (NULL == H.rcd || NULL == H.tag) return OVERFLOW;
 KeyType maxNum = MAXNUM;
 for (i = 0; i < size; i++) {
  H.tag[i] = 0;
  H.rcd[i].key = maxNum;
 }
 H.size = size;
 H.count = 0;
 return OK;
}

// 哈希函数：除留余数法
int Hash(KeyType key, int m) {
 return (3 * key) % m;
}

// 处理哈希冲突：线性探测
void collision(int &p, int m) {
 p = (p + 1) % m;
}

// 在哈希表中查询
Status SearchHash(HashTable H, KeyType key, int &p, int &c) {
 p = Hash(key, H.size);
 int h = p;
 c = 0;
 while ((1 == H.tag[p] && H.rcd[p].key != key) || -1 == H.tag[p]) {
  collision(p, H.size);  c++;
 }

 if (1 == H.tag[p] && key == H.rcd[p].key) return SUCCESS;
 else return UNSUCCESS;
}

//打印哈希表
void printHash(HashTable H)
{
 int  i;
 printf("key : ");
 for (i = 0; i < H.size; i++)
  printf("%3d ", H.rcd[i].key);
 printf("\n");
 printf("tag : ");
 for (i = 0; i < H.size; i++)
  printf("%3d ", H.tag[i]);
 printf("\n\n");
}

// 函数声明：插入哈希表
Status InsertHash(HashTable &H, KeyType key);

// 重建哈希表
Status recreateHash(HashTable &H) {
 RcdType *orcd;
 int *otag, osize, i;
 orcd = H.rcd;
 otag = H.tag;
 osize = H.size;

 InitHashTable(H, hashsize[index++]);
 //把所有元素，按照新哈希函数放到新表中
 for (i = 0; i < osize; i++) {
  if (1 == otag[i]) {
   InsertHash(H, orcd[i].key);
  }
 }
 return OK;
}

// 插入哈希表
Status InsertHash(HashTable &H, KeyType key) {
 int p, c;
 if (UNSUCCESS == SearchHash(H, key, p, c)) { //没有相同key
  if (c*1.0 / H.size < 0.5) { //冲突次数未达到上线
   //插入代码
   H.rcd[p].key = key;
   H.tag[p] = 1;
   H.count++;
   return SUCCESS;
  }
  else recreateHash(H); //重构哈希表 
 }
 return UNSUCCESS;
}

// 删除哈希表
Status DeleteHash(HashTable &H, KeyType key) {
 int p, c;
 if (SUCCESS == SearchHash(H, key, p, c)) {
  //删除代码
  H.tag[p] = -1;
  H.count--;
  return SUCCESS;
 }
 else return UNSUCCESS;
}

int main()
{
 printf("-----哈希表-----\n");
 HashTable H;
 int i;
 int size = 11;
 KeyType array[8] = { 22, 41, 53, 46, 30, 13, 12, 67 };
 KeyType key;

 //初始化哈希表
 printf("初始化哈希表\n");
 if (SUCCESS == InitHashTable(H, hashsize[index++])) printf("初始化成功\n");

 //插入哈希表
 printf("插入哈希表\n");
 for (i = 0; i <= 7; i++) {
  key = array[i];
  InsertHash(H, key);
  printHash(H);
 }

 //删除哈希表
 printf("删除哈希表中key为12的元素\n");
 int p, c;
 if (SUCCESS == DeleteHash(H, 12)) {
  printf("删除成功，此时哈希表为：\n");
  printHash(H);
 }

 //查询哈希表
 printf("查询哈希表中key为67的元素\n");
 if (SUCCESS == SearchHash(H, 67, p, c)) printf("查询成功\n");

 //再次插入，测试哈希表的重建
 printf("再次插入，测试哈希表的重建：\n");
 KeyType array1[8] = { 27, 47, 57, 47, 37, 17, 93, 67 };
 for (i = 0; i <= 7; i++) {
  key = array1[i];
  InsertHash(H, key);
  printHash(H);
 }

 getchar();
 return 0;
}
```

### c++ 实现 unordered_map

```c++
#define MAX_LEN 100000            // the amount of buckets

class MyHashMap {
private:
    vector<pair<int, int>> map[MAX_LEN];       // hash map implemented by array
    
    /** Returns the corresponding bucket index. */
    int getIndex(int key) {
        return key % MAX_LEN;
    }
    
    /** Search the key in a specific bucket. Returns -1 if the key does not existed. */
    int getPos(int key, int index) {
        // Each bucket contains a vector. Iterate all the elements in the bucket to find the target key.
        for (int i = 0; i < map[index].size(); ++i) {
            if (map[index][i].first == key) {
                return i;
            }
        }
        return -1;
    }
    
public:
    /** Initialize your data structure here. */
    MyHashMap() {
        
    }
    
    /** value will always be positive. */
    void put(int key, int value) {
        int index = getIndex(key);
        int pos = getPos(key, index);
        if (pos < 0) {
            map[index].push_back(make_pair(key, value));
        } else {
            map[index][pos].second = value;
        }
    }
    
    /** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */
    int get(int key) {
        int index = getIndex(key);
        int pos = getPos(key, index);
        if (pos < 0) {
            return -1;
        } else {
            return map[index][pos].second;
        }
    }
    
    /** Removes the mapping of the specified value key if this map contains a mapping for the key */
    void remove(int key) {
        int index = getIndex(key);
        int pos = getPos(key, index);
        if (pos >= 0) {
            map[index].erase(map[index].begin() + pos);
        }
    }
};

/**
 * Your MyHashMap object will be instantiated and called as such:
 * MyHashMap obj = new MyHashMap();
 * obj.put(key,value);
 * int param_2 = obj.get(key);
 * obj.remove(key);
 */
```

### C++ 实现 unordered_set

```c++
#define MAX_LEN 100000          // the amount of buckets
class MyHashSet {
private:
    vector<int> set[MAX_LEN];   // hash set implemented by array
    //这里就是vector<int>数组
    /** Returns the corresponding bucket index. */
    int getIndex(int key) {
        return key % MAX_LEN;
    }
    
    /** Search the key in a specific bucket. Returns -1 if the key does not existed. */
    int getPos(int key, int index) {
        // Each bucket contains a list. Iterate all the elements in the bucket to find the target key.
        for (int i = 0; i < set[index].size(); ++i) {
            if (set[index][i] == key) {
                return i;
            }
        }
        return -1;
    }
public:
    /** Initialize your data structure here. */
    MyHashSet() {
        
    }
    
    void add(int key) {
        int index = getIndex(key);
        int pos = getPos(key, index);
        if (pos < 0) {
            // Add new key if key does not exist.
            set[index].push_back(key);
        }
    }
    
    void remove(int key) {
        int index = getIndex(key);
        int pos = getPos(key, index);
        if (pos >= 0) {
            // Remove the key if key exists.
            set[index].erase(set[index].begin() + pos);
        }
    }
    
    /** Returns true if this set did not already contain the specified element */
    bool contains(int key) {
        int index = getIndex(key);
        int pos = getPos(key, index);
        return pos >= 0;
    }
};

/**
 * Your MyHashSet object will be instantiated and called as such:
 * MyHashSet obj = new MyHashSet();
 * obj.add(key);
 * obj.remove(key);
 * bool param_3 = obj.contains(key);
 */
```

## 队列

### c++ 实现队列

为了实现队列，我们可以使用动态数组和指向队列头部的索引。

如上所述，队列应支持两种操作：入队和出队。入队会向队列追加一个新元素，而出队会删除第一个元素。 所以我们需要一个索引来指出起点。

```cpp
#include <iostream>

class MyQueue {
    private:
        // store elements
        vector<int> data;       
        // a pointer to indicate the start position
        int p_start;            
    public:
        MyQueue() {p_start = 0;}
        /** Insert an element into the queue. Return true if the operation is successful. */
        bool enQueue(int x) {
            data.push_back(x);
            return true;
        }
        /** Delete an element from the queue. Return true if the operation is successful. */
        bool deQueue() {
            if (isEmpty()) {
                return false;
            }
            p_start++;
            return true;
        };
        /** Get the front item from the queue. */
        int Front() {
            return data[p_start];
        };
        /** Checks whether the queue is empty or not. */
        bool isEmpty()  {
            return p_start >= data.size();
        }
};

int main() {
    MyQueue q;
    q.enQueue(5);
    q.enQueue(3);
    if (!q.isEmpty()) {
        cout << q.Front() << endl;
    }
    q.deQueue();
    if (!q.isEmpty()) {
        cout << q.Front() << endl;
    }
    q.deQueue();
    if (!q.isEmpty()) {
        cout << q.Front() << endl;
    }
}
```

缺点
上面的实现很简单，但在某些情况下效率很低。 随着起始指针的移动，浪费了越来越多的空间。 当我们有空间限制时，这将是难以接受的。

![image](https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/21/screen-shot-2018-07-21-at-153558.png)

让我们考虑一种情况，即我们只能分配一个最大长度为 5 的数组。当我们只添加少于 5 个元素时，我们的解决方案很有效。 例如，如果我们只调用入队函数四次后还想要将元素 10 入队，那么我们可以成功。

但是我们不能接受更多的入队请求，这是合理的，因为现在队列已经满了。但是如果我们将一个元素出队呢？
![image](https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/21/screen-shot-2018-07-21-at-153713.png)

实际上，在这种情况下，我们应该能够再接受一个元素。

此前，我们提供了一种简单但低效的队列实现。

### c++ 实现循环队列

更有效的方法是使用**循环队列**。

<https://leetcode-cn.com/leetbook/read/queue-stack/kgtj7/>

在循环队列中，我们使用一个数组和两个指针（head 和 tail）。 head 表示队列的起始位置，tail 表示队列的结束位置。

```cpp
class MyCircularQueue {
private:
    vector<int> data;
    int head;
    int tail;
    int size;
public:
    /** Initialize your data structure here. Set the size of the queue to be k. */
    MyCircularQueue(int k) {
        data.resize(k);
        head = -1;
        tail = -1;
        size = k;
    }
    
    /** Insert an element into the circular queue. Return true if the operation is successful. */
    bool enQueue(int value) {
        if (isFull()) {
            return false;
        }
        if (isEmpty()) {
            head = 0;
        }
        tail = (tail + 1) % size;
        data[tail] = value;
        return true;
    }
    
    /** Delete an element from the circular queue. Return true if the operation is successful. */
    bool deQueue() {
        if (isEmpty()) {
            return false;
        }
        if (head == tail) {
            head = -1;
            tail = -1;
            return true;
        }
        head = (head + 1) % size;
        return true;
    }
    
    /** Get the front item from the queue. */
    int Front() {
        if (isEmpty()) {
            return -1;
        }
        return data[head];
    }
    
    /** Get the last item from the queue. */
    int Rear() {
        if (isEmpty()) {
            return -1;
        }
        return data[tail];
    }
    
    /** Checks whether the circular queue is empty or not. */
    bool isEmpty() {
        return head == -1;
    }
    
    /** Checks whether the circular queue is full or not. */
    bool isFull() {
        return ((tail + 1) % size) == head;
    }
};

/**
 * Your MyCircularQueue object will be instantiated and called as such:
 * MyCircularQueue obj = new MyCircularQueue(k);
 * bool param_1 = obj.enQueue(value);
 * bool param_2 = obj.deQueue();
 * int param_3 = obj.Front();
 * int param_4 = obj.Rear();
 * bool param_5 = obj.isEmpty();
 * bool param_6 = obj.isFull();
 */
```

### 两个栈实现一个队列

```c++
class Solution
{
public:
void push(int node) {
stack1.push(node);
}
int pop() {
if(stack2.size()!=0){
int tmp = stack2.top();
stack2.pop();
return tmp;
}
else{
while(stack1.size()!=0){
int tmp = stack1.top();
stack1.pop();
stack2.push(tmp);
}
return pop();
}
}


private:
stack<int> stack1;
stack<int> stack2;
 }；
```
