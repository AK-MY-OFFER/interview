# 手撕

## memcpy

> memcpy函数是c和c++使用的内存拷贝函数，函数原型是：
>
> ```c++
> void *memcpy(void*dest, const void *src, size_t n);
> ```
>
> 表示由src指向地址为起始地址的连续n个字节的数据复制到以dest指向地址为起始地址的空间内。
>
> 与strcpy相比，memcpy并不是遇到'\0'就结束，而是一定会拷贝完n个字节。

注意事项：对于地址重叠的情况，上述函数的行为是未定义的，因此要考虑到此问题

要点：void*类型的指针不能运算，必须强转

​			必须要考虑内存重叠问题(画个图自然就明白了！)

```c++
void * my_memcpy(void *dst, const void *src, size_t count){
	if(dst==nullptr||src==nullptr){
		return nullptr;
	}
    char* temp_dst=(char*)dst;
    char* temp_src=(char*)src;
    if(temp_dst>temp_src&&temp_dst<temp_src+count ){
        //有内存重叠的情况
       	temp_dst=temp_dst+count-1;
        temp_src=temp_src+count-1;
        while(count--){
            *temp_dst--=*temp_src--;
        }
    }else{
        //没有内存重叠的情况
         while(count--){
            *temp_dst++=*temp_src++;
        }
    }
    return (void *)dst;
}  
```

## memmove



## memcpy



## strcat



## strcmp



## strcpy



#### 返回一个指定字节大小的内存，函数返回值代表成功与否

根据 malloc 或 new 的返回值或者异常进行代码编写

![image-20221025205005921](../../../.config/Typora/typora-user-images/image-20221025205005921.png)

## 大小写转化考虑异常



## 进制转换



## 大小端判断



## LFU



## 有衰减机制的 LFU



## LRU



## 有衰减机制的 LRU

