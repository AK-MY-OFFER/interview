# 手撕

## 字符串

### memcpy

> memcpy函数是c和c++使用的内存拷贝函数，函数原型是：
>
> ```c++
> void *memcpy(void*dest, const void *src, size_t n);
> ```
>
> 表示由src指向地址为起始地址的连续n个字节的数据复制到以dest指向地址为起始地址的空间内。
>
> 与strcpy相比，memcpy并不是遇到'\0'就结束，而是一定会拷贝完n个字节。

注意事项：对于地址重叠的情况，上述函数的行为是未定义的，因此要考虑到此问题

要点：void*类型的指针不能运算，必须强转

必须要考虑内存重叠问题(画个图自然就明白了！)

**参数说明**

str1 —— 指向用于存储复制内容的内存起始地址，函数调用时类型强制转换为 void*指针
str2 —— 指向要复制的数据源的内存起始地址，函数调用时类型强制转换为 void* 指针
n    —— 要被复制的内存长度（字节数）

**关于 void* 指针**
  void* 指针，即不定类型指针。C 语言中指针仅占 4 个字节，即存储了一个内存地址，因此编译器在编译指针时必须知道它的类型（即 *号前的部分），才能决定读取数据的长度。如 char* 指针，即 char 类型指针，编译器会从它指向的内存地址起只读取 1 个字节进行编译；而对于 int*指针，即 int 类型指针，编译器则会从它指向的内存地址起读取 4 个字节。
  在 C 语言中 void 一般表示 “空”、“无” 的意思，因此，void* 指针即为 “无类型指针”，正式称呼为 “不定类型指针”。大家也可以将其理解为 C 语言中指针的默认类型。因为不知道指针类型，编译器无法直接对 void*指针操作，程序员在使用 void* 指针时必须将其转换为其他类型的指针来使用，具体用法可以看下面的代码示例。
  至于为什么 memcpy 参数和返回值要用 void*指针，个人理解一方面是为了标准化，规范化，提高普适性，统一输入输出接口；另一方面也是防止程序员忘记进行类型转换吧，毕竟返回的 void* 不转类型就会报错。

**关于 size_t 类型**
  简单理解，C语言中，它底层就是一个 unsigned int 。使用 size_t 主要还是为了提高代码的可移植性、有效性或者可读性。在不同的语言中，不同的平台上，size_t 的定义也许不一样，但这都不是当前程序员关心的问题，我只需要开放接口给后来人就行了。

![memcpy](https://img-blog.csdnimg.cn/96221cc3d71c4872bd146e95ce5e5aee.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATG91aXN0YXJr,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)

```c++
void * my_memcpy(void *dst, const void *src, size_t count){
 if(dst==nullptr||src==nullptr){
  return nullptr;
 }
    char* temp_dst=(char*)dst;
    char* temp_src=(char*)src;
    if(temp_dst>temp_src&&temp_dst<temp_src+count ){
        //有内存重叠的情况
        temp_dst=temp_dst+count-1;
        temp_src=temp_src+count-1;
        while(count--){
            *temp_dst--=*temp_src--;
        }
    }else{
        //没有内存重叠的情况
         while(count--){
            *temp_dst++=*temp_src++;
        }
    }
    return (void *)dst;
}  
```

函数接口：
· 用两个 void*指针接收目标内存地址和源内存地址，一个无符号整型接收内存拷贝长度
· 注意给源内存地址的形参加 const（加在数据类型左边，保护指向的内容），防止篡改原始数据
· 返回值类型也是 void* 指针（保证接口的通用性）
· 得到函数接口 void*memcpy(void* dst, const void*src, unsigned int count)
主体部分：
· 先定义返回值 void* ret = dst; return ret;（返回的是目标内存区域的首地址）
· 拷贝顺序就用简单的正序拷贝实现，即从头开始，逐字节拷贝 count 次
· 用 while 循环实现迭代操作，while ( count-- ) 正好可以跑 count 次
· 循环内部：先赋值，再偏移。（ void*无法直接运算或解引用，需要先转换类型）
· 赋值操作：(char*)dst = *(char*)src;
· 偏移操作：dst = (char *)dst + 1; src = (char*)src + 1;

```
void* memcpy(void* dst, const void* src, unsigned int count)
{
    void* ret = dst;
    while ( count-- )
    {
        *(char *)dst = *(char *)src;
        dst = (char *)dst + 1;
        src = (char *)src + 1;
    }
    return ret;
}

```

第 1 行：函数接口必须不能错！尤其是 src 前必须加 const 修饰，进行保护。
第 3 行：先写返回值，即将目标内存地址保存下来用于返回。
第 4 行：循环条件，根据拷贝长度逐字节循环拷贝，必须用 count-- 不能 --count。
第 6 行：void* 指针每次使用时要先进行类型转换。
第 7-8 行：指针偏移操作，这也是为什么第 3 行要先写返回值。

### memmove

memmove 和 memcpy 的区别

* memmove 会检查内存重叠是否，但 memcpy 不会
* 若目标内存地址头部与源内存地址尾部重叠，正序拷贝时会破坏源内存数据
* 当源内存区域的尾部与目标内存区域的头部重叠时，memmove 会采用倒序拷贝的策略
* 即如下图所示，前两种情况 memmove 采用正序拷贝，第三种情况采用倒序拷贝

![memcpy_vs_memmove](https://img-blog.csdnimg.cn/0d80e75a8f47450eb297e1117d6a91f0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATG91aXN0YXJr,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)

一句话概括：检测内存是否重叠，无重叠则正序逐字节拷贝，重叠则倒序逐字节拷贝。

函数接口：
跟 memcpy 思路一样，`void* memmove(void* dst, const void* src, unsigned int count)`

内存重叠判断：

* 目标内存地址在源内存地址之前，可以正序拷贝：dst <= src
* 目标内存地址在源内存地址之后，但不重叠，可以正序拷贝：dst >= (char *)src + count
* 其他情况，采用倒序拷贝

主体部分：

* 正序拷贝的写法和 memcpy 相同
* 倒序拷贝分两步，先偏移两个指针 dst = (char *)dst + count - 1; src = (char*)src + count - 1;
* 然后和正序拷贝一样用一个 while 循环逐字节拷贝，区别在于指针移动方向不同

```c
void* memmove(void* dst, const void* src, unsigned int count)
{
    void* ret = dst;
    if ( dst <= src || dst >= (char *)src + count )
    {
        while (count--)
        {
            *(char *)dst = *(char *)src;
            dst = (char *)dst + 1;
            src = (char *)src + 1;
        }
    }
    else
    {
        dst = (char *)dst + count - 1;
        src = (char *)src + count - 1;
        while ( count-- )
        {
            *(char *)dst = *(char *)src;
            dst = (char *)dst - 1;
            src = (char *)src - 1;
        }
    }
    return ret;
}

```

* 第 4 行：内存重叠的检查条件必须不能写错！
* 其余手撕代码重点与 memcpy 相同

### strcat

```c
char* mystrcat(char* dst, char* src)
{
 char *res = dst;
 while (*dst != '\0') ++dst;
 while (*src != '\0')
 {
  *dst++ = *src++;
 }
 *dst = '\0';//添加结束符，不然后面有乱码！
 return res;
}
```

### strcmp

```c
int mystrcmp(char* str1, char* str2)
{
 while (*str1 == *str2 && *str1 != '\0')
 {
  ++str1;
  ++str2;
 }
 return *str1 - *str2;
}

```

### strcpy

strcpy和memcpy主要有以下3方面的区别。
1、复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。
2、复制的方法不同。strcpy不需要指定长度，它遇到被复制字符的串结束符"\0"才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度。
3、用途不同。通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy

除了边界条件需要检查以外，还有一个容易被忽视的地方即其返回值一定要是目标内存地址，以支持所谓的链式拷贝。即：

```
strcpy(dest3, strcpy(dest2, strcpy(dest1, src1)));
```

```c
char* strcpy(char* dst, char* src)//内存重叠
{
 assert((dst != NULL && src != NULL));
 char* ret = dst;
 int size = strlen(src) + 1;
 if (dst >= src && dst < src + size)//这个dst的内存在src的范围内，即出现可内存重叠
 {
  dst = dst + size - 1;
  src = src + size - 1;
  while (size--)
  {
   *dst-- = *src--;//将src的值从后向前赋值，赋给dst
  }
 }
 else
 {
  while (size--) //非自我赋值时候
  {
   *dst++ = *src++; 
  }
 }
 return ret;
}
```

### 实现char** strsplit(const chat* src, chat delim)

### 实现 atoi

[8. 字符串转换整数 (atoi)](https://leetcode-cn.com/problems/string-to-integer-atoi/)

请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。

函数 myAtoi(string s) 的算法如下：

* 读入字符串并丢弃无用的前导空格

* 检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。
* 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。
* 将前面步骤读入的这些数字转换为整数（即，"123" -> 123， "0032" -> 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。
* 如果整数数超过 32 位有符号整数范围 [−2^31,  2^31 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −2^31 的整数应该被固定为 −2^31 ，大于 2^31 − 1 的整数应该被固定为 2^31 − 1 。
* 返回整数作为最终结果。

注意：

本题中的空白字符只包括空格字符 ' ' 。
除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。

#### C++ 并统一正负数解析

ps: 对于逼近溢出临界的判断，比较巧妙，需要仔细体会，只要大于7，我们一律返回临界值
如果是正数 2,147,483,648，此时已经溢出,我们返回INT_MAX(2,147,483,647)
如果是负数-2,147,483,648, 此时没有溢出, 返回INT_MIN(-2,147,483,648),实际是它本身

```c++
class Solution {
public:
    int myAtoi(string s) {
        int i = 0, sign = 1, tmp = 0;        //没有符号字符时sign是正数

        while(s[i] == ' ')  ++i;              //1.忽略前导空格

        if(s[i] == '+' || s[i] == '-')        //2.确定正负号
            sign = (s[i++] == '-') ? -1 : 1;  //s[i]为+的话sign依旧为1，为-的话sign为-1

        while(s[i] >= '0' && s[i] <= '9')     //3.检查输入是否合法
        {
            if(tmp > INT_MAX / 10 || (tmp == INT_MAX / 10 && s[i] - '0' > 7)) //4.是否溢出
                return sign == 1 ? INT_MAX : INT_MIN;
            tmp = tmp * 10 + (s[i++] - '0');  //5.不加括号有溢出风险
        }
        return tmp * sign;
    }
};
```

#### C 风格

```c++
class Solution {
private:    
    int myAtoiC(const char* str) {
        // 忽略前导空格
        while (*str == ' ') {
            str++;
        }
        bool minus = false;
        if (*str == '-') minus = true;
        if(*str == '+' || *str == '-') {
            str++;
        }
        // 忽略前导0
        while(*str == '0') {
            str++;
        }
        int num = 0;
        while(*str >= '0' && *str <= '9') {
            // INT_MAX = 2147483647
            // 刚刚好的情况 numNew = numOld * 10 + (*str - '0') == INT_MAX ->  numOld == (INT_MAX - i) / 10;
            int i = *str - '0';
            if (!minus && (num == INT_MAX / 10 && i >= 7) || num > INT_MAX / 10) {
                return INT_MAX;
            } 
            // INT_MIN = -2147483648
            // numOld == (INT_MAX + i) / 10
            if (minus && (num == INT_MIN  / 10 && i >= 8) || num < INT_MIN / 10) {
                return INT_MIN;
            }

            if (!minus)
                num = num * 10 + i;
            else 
                num = num * 10 - i;

            str++;
        }
        return num;

    }
public:
    int myAtoi(string s) {
        return myAtoiC(s.c_str());
    }
};
```

#### C风格改进

```c++
class Solution {
private:    
    int myAtoiC(const char* str) {
        // 忽略前导空格
        while (*str == ' ') str++;
        bool minus = false;
        if (*str == '-') minus = true;
        if(*str == '+' || *str == '-') { str++; }
        // 忽略前导0
        while(*str == '0') str++;
        int num = 0;
        while(*str >= '0' && *str <= '9') {
            int i = *str - '0';
            if (num == INT_MAX / 10 && i > 7 || num > INT_MAX / 10) {
                return minus ? INT_MIN : INT_MAX;
            } 
            num = num * 10 + i;
            str++;
        }
        return minus ? -num : num;
    }
public:
    int myAtoi(string s) {
        return myAtoiC(s.c_str());
    }
};
```

### 实现 string

```c++
class String {
private:
 char* m_data;
    int m_size;
public:
    // 默认构造函数
 String(const char* str = nullptr);
    // 拷贝构造函数
 String(const String& other);
 String(String&& other);
    // 字符串赋值函数
 String& operator=(const String& other);
 String& operator=(String&& other);
    // 析构函数
 ~String();
 int length() { return strlen(data); }
 /*
 其它功能
 */
};
// 构造函数
String::String(const char* str) {
    // 这一步判断是否为nullptr加分点
 if (str == nullptr) {
  m_data = new char[1];
        m_data[0] = '\0';
        m_size = 0;
 }
 else {
  m_size = strlen(str);
        m_data = new char[m_size + 1];
        strcpy(m_data, str);
 }
}
// 拷贝构造函数, 得分点：输入参数是const
String::String(const String& other) {
 m_size = other.m_size;
    m_data = new char[m_size + 1];
    strcpy(m_data, other.m_data);
}
// 移动构造函数
String::String(String&& other) {
 m_data = other.m_data;
 other.m_data = nullptr;
}
// 赋值，注意形参const ,注意返回引用
String& String::operator=(const String& other) {
 // 得分点1：检查自赋值
    if (this == &other)
        return *this;
    // 得分点2：释放原有的内存资源
    delete[] m_data;
    m_size = other.m_size;
    m_data = new char[m_size + 1];
    strcpy(m_data, other.m_data);
    return *this; // 返回本对象的引用
}
// 移动赋值
String& String::operator=(String&& other) {
 if (this == &other) 
        return *this;
 delete[] m_data;
 m_data = other.m_data;
 other.m_data = nullptr;
 return *this;
}
// 析构
String::~String() { 
 delete[] m_data;
}
```

需要注意的点：

delete[] nullptr会发生什么问题？试一试:一切正常

```c++
int main()
{
    int* p = new int[1];
    delete[] p;
    p = nullptr;
    delete[] p;
    return 0;
}
```





## 返回一个指定字节大小的内存，函数返回值代表成功与否

根据 malloc 或 new 的返回值或者异常进行代码编写

![image-20221025205005921](../../../.config/Typora/typora-user-images/image-20221025205005921.png)

## 大小写转化考虑异常

```

```



## 进制转换

```

```



## 大小端判断

端存储：字数据的高字节存储在低地址中

小端存储：字数据的低字节存储在低地址中

例如：32bit的数字0x12345678

**所以在Socket编程中，往往需要将操作系统所用的小端存储的IP地址转换为大端存储，这样才能进行网络传输**

小端模式中的存储方式为：

![img](https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.4.2/202102/1564134200013.png)

大端模式中的存储方式为：

![img](https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.4.2/202102/1564134220855.png)

了解了大小端存储的方式，如何在代码中进行判断呢？下面介绍两种判断方式：

**方式一：使用强制类型转换**-这种法子不错

```c++
#include <iostream>
using namespace std;
int main()
{
    int a = 0x1234;
    //由于int和char的长度不同，借助int型转换成char型，只会留下低地址的部分
    char c = (char)(a);
    if (c == 0x12)
        cout << "big endian" << endl;
    else if(c == 0x34)
        cout << "little endian" << endl;
}
```

**方式二：巧用union联合体**

```c++
#include <iostream>
using namespace std;
//union联合体的重叠式存储，endian联合体占用内存的空间为每个成员字节长度的最大值
union endian
{
    int a;
    char ch;
};
int main()
{
    endian value;
    value.a = 0x1234;
    //a和ch共用4字节的内存空间
    if (value.ch == 0x12)
        cout << "big endian"<<endl;
    else if (value.ch == 0x34)
        cout << "little endian"<<endl;
}
```

## LFU

### 有衰减机制的 LFU

## LRU

LRU(Least Recently Used) 即最近最少使用，属于典型的内存淘汰机制。

根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”，其思路如下图所示：

<img src="https://cdn.jsdelivr.net/gh/luogou/cloudimg/data/202203281451446.png" alt="img" style="zoom: 50%;float:left" />

该算法需要达到两个目的：①可以轻易的更新最新的访问数据。②轻易的找出最近最少未使用的数据。所以要用到哈希表+双向链表实现。利用map，获取key对应的value是O(1)，利用双向链表，实现新增和删除都是O(1)。

> 传统意义的LRU算法是为每一个Cache对象设置一个计数器，每次Cache命中则给计数器+1，而Cache用完，需要淘汰旧内容，放置新内容时，就查看所有的计数器，并将最少使用的内容替换掉。它的弊端很明显，如果Cache的数量少，问题不会很大， 但是如果Cache的空间过大，达到10W或者100W以上，一旦需要淘汰，则需要遍历所有计数器，其性能与资源消耗是巨大的。效率也就非常的慢了。双链表LRU的原理： 将Cache的所有位置都用双链表连接起来，当一个位置被命中之后，就将通过调整链表的指向，将该位置调整到链表头的位置，新加入的Cache直接加到链表头中。 这样，在多次进行Cache操作后，最近被命中的，就会被向链表头方向移动，而没有命中的，则向链表后面移动，链表尾则表示最近最少使用的Cache。当需要替换内容时候，链表的最后位置就是最少被命中的位置，我们只需要淘汰链表最后的部分即可。

LRU数据结构如下图：

<img src="https://cdn.jsdelivr.net/gh/luogou/cloudimg/data/202203281937301.jpeg" alt="HashLinkedList" style="zoom:67%;float:left" />

根据上图我们可以分析一下：

1. 如果我们每次默认从链表尾部添加元素，那么显然越靠尾部的元素就是最近使用的，越靠头部的元素就是最久未使用的。
2. 对于某一个 `key`，我们可以通过哈希表快速定位到链表中的节点，从而取得对应 `val`。
3. 链表显然是支持在任意位置快速插入和删除的，改改指针就行。只不过传统的链表无法按照索引快速访问某一个位置的元素，而这里借助哈希表，可以通过 `key` 快速映射到任意一个链表节点，然后进行插入和删除。

* 版本1：自己实现循环链表存储，没有用API

 ```c++
 /********************不用API的版本*************************/
 /********************简单说一下思路*************************/
 //1.首先hash表用的是unordered_map来实现，用来查找key对应的node节点，所以hash表应该是[key,node]形式存储
 //2.LRUCache这个类实现双向链表的添加，删除，更新和遍历
 //3.同时这个类还要实现get和put两个功能
 //4.我这里用的是循环双向链表，因此查找链表尾端的元素为O(1)，正常的双向链表是O(n)
 //总结：最重要的就是hash表中的key对应的不是int而是一个node节点，这个要记住
 #include<unordered_map>
 #include<iostream>
 struct Node{
     int key;
     int value;
     Node* pre;
     Node* next;
     Node(){}
     Node(int k, int v):key(k), value(v), pre(nullptr), next(nullptr){}
 };
 
 class LRUCache{
 private:
     //通过key可以找到位于链表中的节点
     std::unordered_map<int, Node*> hash;
     int capacity;
     Node* head_node;
 public:
     LRUCache(int cap){
         capacity = cap;
         head_node = new Node();
         //初始化dummy_Node,next和pre都指向自己
         head_node->next = head_node->pre = head_node;
     }
     //将新来的插入双向链表头部
     void add_Node(Node* n);
     //将某个节点拿出来重新插入头部
     void update_Node(Node* n);
     //移除链表中最后一个（最久未使用）
     void pop_back();
     //输出LRU结构
     void show();
     int get(int key);
     void put(int key, int value);
 };
 
 //注意，该节点可能是新节点，也可能是已经存在的有重新入链表的节点
 void LRUCache::add_Node(Node* n){
     //表示当前节点n就是dummy的next节点，不用加入
     if(n->pre == head_node){
         return;
     }
     //将节点n插入head_node后面
     n->pre = head_node;
     n->next = head_node->next;
     head_node->next->pre = n;
     head_node->next = n;
 }
 
 void LRUCache::update_Node(Node* n){
     //表示当前节点n就是dummy的next节点，不用断掉
     if(n->pre == head_node){
         return;
     }
     n->next->pre = n->pre;
     n->pre->next = n->next;
     add_Node(n);
 }
 
 //弹出链表的最后一个，由于是循环链表，就是head_node->pre
 void LRUCache::pop_back(){
     Node* tmp = head_node->pre;
     head_node->pre = tmp->pre;
     tmp->pre->next = head_node;
     //删除unordered_map中的key
     hash.erase(tmp->key);
 }
 
 void LRUCache::show(){
     //链表中没有节点，退出
     if(head_node->next = head_node){
         return;
     }
     Node* tmp = head_node->next;
     while(tmp->next != head_node){
         std::cout<<"key:"<<tmp->key<<",vlaue:"<<tmp->value<<std::endl;
     }
 }
 int LRUCache::get(int key){
     auto it = hash.find(key);
     if(it == hash.end()){
         std::cout<<"there is no key"<<std::endl;
         return -1;
     }
     //取出key对应的node节点
     Node* node = it->second;
     update_Node(node);
     return node->value;
 
 }
 void LRUCache::put(int key, int value){
     auto it = hash.find(key);
     if(it == hash.end()){
         Node* node = new Node(key, value);
         add_Node(node);
         hash.insert({key, node});
         if(hash.size() > capacity){
             
             pop_back();
         }
     }else{
         it->second->value = value;
         update_Node(it->second);
     }
 }
 ```

* 版本2：使用deque，为什么使用deque说的很清楚

 ```c++
 /****************注意unordered_map的插入************/
 
 #include <iostream>
 #include <deque>
 #include <unordered_map>
 #include <list>
 
 class LRUCache{
 private:
     int capacity;
     //1.之所以用deque不用list是因为移除尾部元素的时候，deque方便
     //2.deque里面可以存储自定的node类型，也可以用pair表示，这里我用pair了
     std::deque<std::pair<int, int>> my_deque;
     //通过key找到对应key在deque中的位置
     std::unordered_map<int, std::deque<std::pair<int, int>>::iterator> hash;
 public:
     LRUCache(int cap):capacity(cap){}
     int get(int key);
     void put(int key, int value);
 };
 
 int LRUCache::get(int key){
     if(hash.find(key) == hash.end()){
         std::cout<<"there is no key"<<std::endl;
         return -1;
     }
     std::pair<int, int> tmp = *hash[key];
     my_deque.erase(hash[key]);
     my_deque.push_front(tmp);
     //更新hash表中对应key位于deque的位置
     hash[key] = my_deque.begin();
     return tmp.second;
 }
 
 void LRUCache::put(int key, int value){
     if(hash.find(key) == hash.end()){
         if(my_deque.size() >= capacity){
             //把hash表中的抹除，然后删除deque中的
             auto it = my_deque.back();
             hash.erase(it.first);
             my_deque.pop_back();
             my_deque.push_front({key, value});
             hash.insert({key, my_deque.begin()});
         }else{
             my_deque.push_front({key, value});
             hash.insert({key, my_deque.begin()});
         }
     }else{
         //更新就行
         my_deque.erase(hash[key]);
         my_deque.push_front({key, value});
         //更新hash表中key的位置
         hash[key] = my_deque.begin();
     }
 }
 ```

### 有衰减机制的 LRU

### LRU 应用场景

## KMP

## 实现 sqrt

[69. x 的平方根](https://leetcode-cn.com/problems/sqrtx/)

### 方法一：袖珍计算器算法

「袖珍计算器算法」是一种用指数函数 exp 和对数函数 ln 代替平方根函数的方法。我们通过有限的可以使用的数学函数，得到我们想要计算的结果。

我们将 $\sqrt{x} $ 写成幂的形式 $x^{1/2} $

 ，再使用自然对数 e 进行换底，即可得到

$\sqrt{x} = x^{1/2} = (e ^ {\ln x})^{1/2} = e^{\frac{1}{2} \ln x}$

**注意：** 由于计算机无法存储浮点数的精确值,有误差.例如当 x=2147395600 时，$e^{\frac{1}{2} \ln x} $的计算结果与正确值 46340相差 $10^{-11} $ ，这样在对结果取整数部分时，会得到 46339 这个错误的结果。

因此在得到结果的整数部分ans 后，我们应当找出ans 与 ans+1 中哪一个是真正的答案。

```c++
class Solution {
public:
    int mySqrt(int x) {
        if (x == 0) {
            return 0;
        }
        int ans = exp(0.5 * log(x));
        return ((long long)(ans + 1) * (ans + 1) <= x ? ans + 1 : ans);
    }
};
```

### 方法二：二分查找

由于 x 平方根的整数部分 ans 是满足 $k^2 \leq x$的最大 k 值，因此我们可以对 k 进行二分查找，从而得到答案。

二分查找的下界为 0，上界可以粗略地设定为 x。在二分查找的每一步中，我们只需要比较中间元素 mid 的平方与 x 的大小关系，并通过比较的结果调整上下界的范围。由于我们所有的运算都是整数运算，不会存在误差。

```c++
int mySqrt(int x) {
        // 试一试二分查找是否能够解决啦啦啦
        // k * k <= x 找最大的k
        int left = 0, right = x;
        // [left, right]
        int ans = 0;
        while (left <= right) {
            int mid = left + (right - left >> 1);
            if (static_cast<long long>(mid) * mid > x) {
                right = mid - 1;
            } else {
                ans = mid;
                left = mid + 1;
            } 
        }
        return ans;
    }
```

### 方法三：牛顿迭代

牛顿迭代法是一种可以用来快速求解函数**零点**的方法。

为了叙述方便，我们用 C 表示待求出平方根的那个整数。

显然，C 的平方根就是函数$y = f(x) = x^2 - C$ 的零点。

![fig1](https://assets.leetcode-cn.com/solution-static/69/69_fig1.png)

算法

我们选择x0 = C作为初始值。

在每一步迭代中，我们通过当前的交点xi,找到图像上Pi (xi, xi^2^ - C)

然后作切线，斜率f^'^'(xi) = 2xi, 经过点Pi 与x轴相交。

切线方程 y = 2xi x - (xi^2^ + C), y = 0即新的交点

Pi+1 ( 1/2 (xi + C / xi) ,0)

**迭代到何时才算结束**？

每一次迭代后，我们都会距离零点更进一步，所以当相邻两次迭代得到的交点非常接近时，我们就可以断定。一般来说，可以判断相邻两次迭代的结果的差值是否小于一个极小的非负数 $\epsilon$，其中 $\epsilon$ 一般可以取 $10^{-6}$

```c++
class Solution {
public:
    int mySqrt(int x) {
        if (x == 0) {
            return 0;
        }

        double C = x, x0 = x;
        while (true) {
            double xi = 0.5 * (x0 + C / x0);
            if (fabs(x0 - xi) < 1e-7) {
                break;
            }
            x0 = xi;
        }
        return int(x0);
    }
};
```

## 建立二叉树



## 哈希表

### 手撕哈希表 C语言

```cpp
#include<stdio.h>
#include<stdlib.h>

#define SUCCESS 1
#define UNSUCCESS 0
#define OVERFLOW -1
#define OK 1
#define ERROR -1
#define MAXNUM 9999  // 用于初始化哈希表的记录 key

typedef int Status;
typedef int KeyType;

// 哈希表中的记录类型
typedef struct {
 KeyType key;
}RcdType;

// 哈希表类型
typedef struct {
 RcdType *rcd;
 int size;
 int count;
 int *tag;
}HashTable;

// 哈希表每次重建增长后的大小
int hashsize[] = { 11, 31, 61, 127, 251, 503 };
int index = 0;

// 初始哈希表
Status InitHashTable(HashTable &H, int size) {
 int i;
 H.rcd = (RcdType *)malloc(sizeof(RcdType)*size);
 H.tag = (int *)malloc(sizeof(int)*size);
 if (NULL == H.rcd || NULL == H.tag) return OVERFLOW;
 KeyType maxNum = MAXNUM;
 for (i = 0; i < size; i++) {
  H.tag[i] = 0;
  H.rcd[i].key = maxNum;
 }
 H.size = size;
 H.count = 0;
 return OK;
}

// 哈希函数：除留余数法
int Hash(KeyType key, int m) {
 return (3 * key) % m;
}

// 处理哈希冲突：线性探测
void collision(int &p, int m) {
 p = (p + 1) % m;
}

// 在哈希表中查询
Status SearchHash(HashTable H, KeyType key, int &p, int &c) {
 p = Hash(key, H.size);
 int h = p;
 c = 0;
 while ((1 == H.tag[p] && H.rcd[p].key != key) || -1 == H.tag[p]) {
  collision(p, H.size);  c++;
 }

 if (1 == H.tag[p] && key == H.rcd[p].key) return SUCCESS;
 else return UNSUCCESS;
}

//打印哈希表
void printHash(HashTable H)
{
 int  i;
 printf("key : ");
 for (i = 0; i < H.size; i++)
  printf("%3d ", H.rcd[i].key);
 printf("\n");
 printf("tag : ");
 for (i = 0; i < H.size; i++)
  printf("%3d ", H.tag[i]);
 printf("\n\n");
}

// 函数声明：插入哈希表
Status InsertHash(HashTable &H, KeyType key);

// 重建哈希表
Status recreateHash(HashTable &H) {
 RcdType *orcd;
 int *otag, osize, i;
 orcd = H.rcd;
 otag = H.tag;
 osize = H.size;

 InitHashTable(H, hashsize[index++]);
 //把所有元素，按照新哈希函数放到新表中
 for (i = 0; i < osize; i++) {
  if (1 == otag[i]) {
   InsertHash(H, orcd[i].key);
  }
 }
 return OK;
}

// 插入哈希表
Status InsertHash(HashTable &H, KeyType key) {
 int p, c;
 if (UNSUCCESS == SearchHash(H, key, p, c)) { //没有相同key
  if (c*1.0 / H.size < 0.5) { //冲突次数未达到上线
   //插入代码
   H.rcd[p].key = key;
   H.tag[p] = 1;
   H.count++;
   return SUCCESS;
  }
  else recreateHash(H); //重构哈希表 
 }
 return UNSUCCESS;
}

// 删除哈希表
Status DeleteHash(HashTable &H, KeyType key) {
 int p, c;
 if (SUCCESS == SearchHash(H, key, p, c)) {
  //删除代码
  H.tag[p] = -1;
  H.count--;
  return SUCCESS;
 }
 else return UNSUCCESS;
}

int main()
{
 printf("-----哈希表-----\n");
 HashTable H;
 int i;
 int size = 11;
 KeyType array[8] = { 22, 41, 53, 46, 30, 13, 12, 67 };
 KeyType key;

 //初始化哈希表
 printf("初始化哈希表\n");
 if (SUCCESS == InitHashTable(H, hashsize[index++])) printf("初始化成功\n");

 //插入哈希表
 printf("插入哈希表\n");
 for (i = 0; i <= 7; i++) {
  key = array[i];
  InsertHash(H, key);
  printHash(H);
 }

 //删除哈希表
 printf("删除哈希表中key为12的元素\n");
 int p, c;
 if (SUCCESS == DeleteHash(H, 12)) {
  printf("删除成功，此时哈希表为：\n");
  printHash(H);
 }

 //查询哈希表
 printf("查询哈希表中key为67的元素\n");
 if (SUCCESS == SearchHash(H, 67, p, c)) printf("查询成功\n");

 //再次插入，测试哈希表的重建
 printf("再次插入，测试哈希表的重建：\n");
 KeyType array1[8] = { 27, 47, 57, 47, 37, 17, 93, 67 };
 for (i = 0; i <= 7; i++) {
  key = array1[i];
  InsertHash(H, key);
  printHash(H);
 }

 getchar();
 return 0;
}
```

### c++ 实现 unordered_map

```c++
#define MAX_LEN 100000            // the amount of buckets

class MyHashMap {
private:
    vector<pair<int, int>> map[MAX_LEN];       // hash map implemented by array
    
    /** Returns the corresponding bucket index. */
    int getIndex(int key) {
        return key % MAX_LEN;
    }
    
    /** Search the key in a specific bucket. Returns -1 if the key does not existed. */
    int getPos(int key, int index) {
        // Each bucket contains a vector. Iterate all the elements in the bucket to find the target key.
        for (int i = 0; i < map[index].size(); ++i) {
            if (map[index][i].first == key) {
                return i;
            }
        }
        return -1;
    }
    
public:
    /** Initialize your data structure here. */
    MyHashMap() {
        
    }
    
    /** value will always be positive. */
    void put(int key, int value) {
        int index = getIndex(key);
        int pos = getPos(key, index);
        if (pos < 0) {
            map[index].push_back(make_pair(key, value));
        } else {
            map[index][pos].second = value;
        }
    }
    
    /** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */
    int get(int key) {
        int index = getIndex(key);
        int pos = getPos(key, index);
        if (pos < 0) {
            return -1;
        } else {
            return map[index][pos].second;
        }
    }
    
    /** Removes the mapping of the specified value key if this map contains a mapping for the key */
    void remove(int key) {
        int index = getIndex(key);
        int pos = getPos(key, index);
        if (pos >= 0) {
            map[index].erase(map[index].begin() + pos);
        }
    }
};

/**
 * Your MyHashMap object will be instantiated and called as such:
 * MyHashMap obj = new MyHashMap();
 * obj.put(key,value);
 * int param_2 = obj.get(key);
 * obj.remove(key);
 */
```

### C++ 实现 unordered_set

```c++
#define MAX_LEN 100000          // the amount of buckets
class MyHashSet {
private:
    vector<int> set[MAX_LEN];   // hash set implemented by array
    //这里就是vector<int>数组
    /** Returns the corresponding bucket index. */
    int getIndex(int key) {
        return key % MAX_LEN;
    }
    
    /** Search the key in a specific bucket. Returns -1 if the key does not existed. */
    int getPos(int key, int index) {
        // Each bucket contains a list. Iterate all the elements in the bucket to find the target key.
        for (int i = 0; i < set[index].size(); ++i) {
            if (set[index][i] == key) {
                return i;
            }
        }
        return -1;
    }
public:
    /** Initialize your data structure here. */
    MyHashSet() {
        
    }
    
    void add(int key) {
        int index = getIndex(key);
        int pos = getPos(key, index);
        if (pos < 0) {
            // Add new key if key does not exist.
            set[index].push_back(key);
        }
    }
    
    void remove(int key) {
        int index = getIndex(key);
        int pos = getPos(key, index);
        if (pos >= 0) {
            // Remove the key if key exists.
            set[index].erase(set[index].begin() + pos);
        }
    }
    
    /** Returns true if this set did not already contain the specified element */
    bool contains(int key) {
        int index = getIndex(key);
        int pos = getPos(key, index);
        return pos >= 0;
    }
};

/**
 * Your MyHashSet object will be instantiated and called as such:
 * MyHashSet obj = new MyHashSet();
 * obj.add(key);
 * obj.remove(key);
 * bool param_3 = obj.contains(key);
 */
```



## 可重用内存的 vector





## 多线程

### 生产者消费者

CPP20 STL-Cookbook

单生产者单消费者

[CPP-20-STL-Cookbook/producer-consumer.cpp at main · PacktPublishing/CPP-20-STL-Cookbook (github.com)](https://github.com/PacktPublishing/CPP-20-STL-Cookbook/blob/main/chap09/producer-consumer.cpp)

```c++
//  producer-consumer.cpp
//  as of 2022-03-29 bw [bw.org]

#include <format>
#include <iostream>
#include <deque>
#include <tuple>
#include <condition_variable>
#include <thread>

using std::format;
using std::cout;
using std::mutex;
using std::thread;

using namespace std::chrono_literals;
namespace this_thread = std::this_thread;

using guard_t = std::lock_guard<std::mutex>;
using lock_t = std::unique_lock<std::mutex>;

constexpr size_t num_items{ 10 };
constexpr auto delay_time{ 200ms };

std::deque<size_t> q{};
std::mutex mtx{};
std::condition_variable cond{};
bool finished{};

void producer() {
    for(size_t i{}; i < num_items; ++i) {
        this_thread::sleep_for(delay_time);
        guard_t x{ mtx };
        q.push_back(i);
        cond.notify_all();
    }

    guard_t x{ mtx };
    finished = true;
    cond.notify_all();
}

void consumer() {
    while(!finished) {
        lock_t lck{ mtx };
        cond.wait(lck, []{ return !q.empty() || finished; });
        while(!q.empty()) {
            cout << format("Got {} from the queue\n", q.front());
            q.pop_front();
        }
    }
}

int main() {
    thread t1{ producer };
    thread t2{ consumer };
    t1.join();
    t2.join();
    cout << "finished!\n";
}
```

多生产者多消费者

[CPP-20-STL-Cookbook/multi-producer-consumer.cpp at main · PacktPublishing/CPP-20-STL-Cookbook (github.com)](https://github.com/PacktPublishing/CPP-20-STL-Cookbook/blob/main/chap09/multi-producer-consumer.cpp)

```c++
//  multi-producer-consumer.cpp
//  as of 2022-03-06 bw [bw.org]

#include <format>
#include <iostream>
#include <list>
#include <string>
#include <deque>
#include <thread>
#include <future>
#include <mutex>
#include <condition_variable>
#include <chrono>

using std::format;
using std::cout;
using std::string;
using std::list;
using std::mutex;
using std::unique_lock;
using std::async;
using std::future;
using std::condition_variable;

using namespace std::chrono_literals;
namespace this_thread = std::this_thread;

constexpr auto delay_time{ 50ms };
constexpr auto consumer_wait{ 100ms };
constexpr size_t queue_limit{ 5 };
constexpr size_t num_items{ 15 };
constexpr size_t num_producers{ 3 };
constexpr size_t num_consumers{ 5 };

std::deque<string> qs{};
mutex q_mutex{};
condition_variable cv_producer{};
condition_variable cv_consumer{};
bool production_complete{};

void producer(const size_t id) {
    for(size_t i{}; i < num_items; ++i) {
        this_thread::sleep_for(delay_time * id);
        unique_lock<mutex> lock(q_mutex);
        cv_producer.wait(lock, [&]{ return qs.size() < queue_limit; });
        qs.push_back(format("pid {}, qs  {}, item {:02}\n", id, qs.size(), i + 1));
        cv_consumer.notify_all();
    }
}

void consumer(const size_t id) {
    while(!production_complete) {
        unique_lock<mutex> lock(q_mutex);
        cv_consumer.wait_for(lock, consumer_wait, [&]{ return !qs.empty(); });
        if(!qs.empty()) {
            cout << format("cid {}: {}", id, qs.front());
            qs.pop_front();
        }
        cv_producer.notify_all();
    }
}

int main() {
    list<future<void>> producers;
    list<future<void>> consumers;

    for(size_t i{}; i < num_producers; ++i) {
        producers.emplace_back(async(producer, i));
    }

    for(size_t i{}; i < num_consumers; ++i) {
        consumers.emplace_back(async(consumer, i));
    }
    
    for(auto& f : producers) f.wait();
    production_complete = true;
    cout << "producers done.\n";

    for(auto& f : consumers) f.wait();
    cout << "consumers done.\n";
}
```



### 手搓一个模拟死锁的代码

```C
#include <pthread.h>
#include <unistd.h>
#include <stdio.h>

pthread_mutex_t m_mutex1, m_mutex2;
int A = 0, B = 0;

void* threadFunc1(void* args) {
    pthread_mutex_lock(&m_mutex1);
    A = 1;
 	printf("thread 1 write source A\n");
 	usleep(100);

    pthread_mutex_lock(&m_mutex2);
    B = 1;
	printf("thread 1 write source B\n");
 
 //解锁，实际上是跑不到这里的，因为前面已经死锁了
    pthread_mutex_unlock(&m_mutex2);
    pthread_mutex_unlock(&m_mutex1);

    return NULL;
}

void* threadFunc2(void* args) {
    pthread_mutex_lock(&m_mutex2);
    B = 1;
	printf("thread 2 write source B\n");
	usleep(100);

    pthread_mutex_lock(&m_mutex1);
    A = 1;
	printf("thread 2 write source A\n");
 
    //解锁，实际上是跑不到这里的，因为前面已经死锁了
    pthread_mutex_unlock(&m_mutex1);
    pthread_mutex_unlock(&m_mutex2);

    return NULL;
}

int main() {
    if(pthread_mutex_init(&m_mutex1, 0) != 0) {
        printf("init mutex 1 failed\n");
        return -1;
    }
    if(pthread_mutex_init(&m_mutex2, 0) != 0) {
        printf("init mutex 2 failed\n");
        return -1;
    }

    pthread_t hThread1, hThread2;
    if(pthread_create(&hThread1, NULL, &threadFunc1, NULL) != 0) {
        printf("create thread1 failed\n");
        return -1;
    }
    if(pthread_create(&hThread2, NULL, &threadFunc2, NULL) != 0) {
        printf("create thread1 failed\n");
        return -1;
    }

    while(1) {
        sleep(1);
    }

    pthread_mutex_destroy(&m_mutex1);
    pthread_mutex_destroy(&m_mutex2);

    return 0;
}
```

### 线程池

```c++
#pragma onece

#include <utility>
#include <vector>
#include <memory>
#include <queue>
#include <atomic>
#include <mutex>
#include <condition_variable>
#include <functional>
#include <thread>
#include <future>
#include <iostream>

const int TASK_MAX_THRESHOLD = INT32_MAX;
const int THREAD_MAX_THRESHOLD = 10;
const int THREAD_MAX_IDLE_TIME = 60; //seconds
/**
 * @brief 线程池支持的模式
 */
enum class PoolMode {
	MODE_FIXED,     // 固定数量的线程
	MODE_CACHED,    // 线程数量可动态增长
};

/**
 * @brief 线程类型
 */
class Thread
{
public:
    //线程函数对象类型
    using ThreadFunc = std::function<void(int)>;
    //线程构造函数
    explicit Thread(ThreadFunc func)
            :func_(std::move(func))
            ,threadId_(generatedId_++)
    {}
    //线程析构函数
    ~Thread() = default;
    //启动线程
    void start() {
        //创建一个线程来执行线程函数
        //ThreadPool::threadFunc() -> Thread类中绑定接收 -> func -> func_
        std::thread t(func_, threadId_);//c++11来将，线程对象t   和  线程执行函数func_
        t.detach(); //设置分离线程    线程对象和线程执行函数分开，，，线程对象t离开作用域会被析构，detach之后不影响线程函数的执行
    }
    //获取线程id
    int getId() const {
        return threadId_;
    }
private:

    ThreadFunc func_;
    int threadId_;//保存线程id
    static int generatedId_;
};

int Thread::generatedId_ = 0;

/**
 * @brief 线程池类型
 */
class ThreadPool {
public:
    /// 线程池构造
    ThreadPool()
            : initThreadSize_(0)
            , taskSize_(0)
            , taskQueMaxSizeThreshold_(TASK_MAX_THRESHOLD)
            , poolMode_(PoolMode::MODE_FIXED)
            , isPoolRunning_(false)
            , idleThreadSize_(0)
            , threadSizeThreshold_(THREAD_MAX_THRESHOLD)
            , curThreadSize_(0) {
    }


    /// 线程池析构 用户的线程（需要线程通信）
    ~ThreadPool() {
        isPoolRunning_ = false;
        // 等待线程池所有的线程返回 两种状态：阻塞 & 正在执行任务中
        std::unique_lock<std::mutex> lock(taskQueMtx_);\
        // 都给唤醒了
        notEmpty_.notify_all();// 等待 ==> 阻塞
        // 等待容器里的线程对象都清空了才析构,每个线程回收的时候会唤醒 exitCond_ 来检查是否满足条件
        exitCond_.wait(lock,[&]()->bool {return threads_.empty();});
    }

    /// 开启线程池
    void start(unsigned int initThreadSize = std::thread::hardware_concurrency())
    {
        //设置线程池运行状态
        isPoolRunning_ = true;

        //记录初始线程个数
        initThreadSize_ = initThreadSize;
        //记录当前线程个数
        curThreadSize_ = initThreadSize;

        //集中创建线程对象
        for (int i = 0; i < initThreadSize_; i++)
        {
            //创建thread线程对象的时候，把线程函数给到thread线程对象
            auto ptr = std::make_unique<Thread>([this](auto && PH1) { threadFunc(std::forward<decltype(PH1)>(PH1)); });
            int threadId = ptr->getId();
            threads_.emplace(threadId, std::move(ptr));
        }

        //启动所有线程
        for (int i = 0; i < initThreadSize_; i++)
        {
            threads_[i]->start();
            idleThreadSize_++;//记录空闲线程数量
        }
    }

    /// 设置线程池模式
    void setMode(PoolMode mode) {
        if(checkRunningState()) return;
        poolMode_ = mode;
    }

    /// 设置任务队列上限阈值
    void setTaskQueMaxThreshHold(int threshold) {
        if(checkRunningState()) return;
        taskQueMaxSizeThreshold_ = threshold;
    }

    /// 设置线程池 cached 模式下线程阈值
    void setThreadSizeThreshHold(int threshold) {
        if(checkRunningState()) return;
        if(poolMode_ == PoolMode::MODE_CACHED) {
            threadSizeThreshold_ = threshold;
        }
    }


    /// 设置初始的线程数量
    void setInitThreadSize(int size) {
        if(checkRunningState()) return;
        initThreadSize_ = size;
    }

	/// 给线程池提交任务
    /// 使用可变参模板编程，让 submitTask 可以接收任意任务函数和任意数量的参数
    /// pool.submitTask(sum1, 10, 20);
    /// 返回值 future<>  用 decltype 推
    template<typename Func, typename... Args>
    auto submitTask(Func&& func, Args&&...args) -> std::future<decltype(func(args...))> {
        //打包任务 放到任务队列中
        using RType = decltype(func(args...));
        auto task = std::make_shared<std::packaged_task<RType()>>(
                std::bind(std::forward<Func>(func), std::forward<Args>(args)...));
        std::future<RType> result = task->get_future();

        // 获取锁
        std::unique_lock<std::mutex> lock(taskQueMtx_);
        // 用户提交任务，最长不能阻塞超过 1s, 否则提交任务失败
        if (!notFull_.wait_for(lock, std::chrono::seconds(1),
                               [&]()->bool {return taskQue_.size() < (size_t)taskQueMaxSizeThreshold_; }))
        {
            //表示notFull_等待1s，条件依然没有满足
            std::cerr << "task queue is full, submit task fail." << std::endl;
            auto taskEmpty = std::make_shared<std::packaged_task<RType()>>(
                    []()->RType { return RType(); });
            (*taskEmpty)();
            return taskEmpty->get_future();
        }

        // 如果有空余，把任务放到任务队列中
        // using Task = std::function<void()>;
        taskQue_.emplace([task]() {(*task)();});
        ++taskSize_;

        // 因为新放了任务，任务队列肯定不空了，在 notEmpty_ 上进行通知, 赶快分配线程执行任务 （消费）
        notEmpty_.notify_all();

        // cached模式 任务处理比较紧急 场景：小而快的任务
        // 需要根据任务数量和空闲线程数量，判断是否需要创建新的线程出来
        if(poolMode_ == PoolMode::MODE_CACHED
           && taskSize_ > idleThreadSize_
           &&  curThreadSize_ < threadSizeThreshold_) {
            std::cout << "create new thread..." << std::endl;
            // 创建新线程对象
            auto ptr = std::make_unique<Thread>([this](auto && PH1) { threadFunc(std::forward<decltype(PH1)>(PH1)); });
            int threadId = ptr->getId();
            threads_.emplace(threadId, std::move(ptr));

            // 启动线程
            threads_[threadId]->start();

            // 修改线程个数相关变量
            curThreadSize_++;
            idleThreadSize_++;
        }

        return result;
    }

	/// 禁止拷贝构造和赋值
	ThreadPool(const ThreadPool&) = delete;
	ThreadPool& operator=(const ThreadPool&) = delete;

private:
    /// 定义线程函数 线程池的所有线程从任务队列里 消费任务
    void threadFunc(int threadid) {
        auto lastTime = std::chrono::high_resolution_clock::now();
        while(isPoolRunning_){
            Task task;
            {
                // 先取锁
                std::unique_lock<std::mutex> lock(taskQueMtx_);
                std::cout << "tid:"<< std::this_thread::get_id() << "尝试获取任务..." << std::endl;

                // 锁 + 双重判断
                while(isPoolRunning_ && taskQue_.empty()) {   // 任务队列没任务，就等 1s 看看情况；有任务就直接出去消费
                    if (poolMode_ == PoolMode::MODE_CACHED) {
                        // cached 模式下，有可能已经创建了很多的线程，但是空闲时间超过 60s
                        // 超过 initThreadSize_ 数量的线程要进行回收
                        // 当前时间 - 上次线程执行的时间 > 60s
                        // 每 1s 中返回一次 怎么区分超时返回还是有任务待执行返回？

                        if (std::cv_status::timeout ==
                            notEmpty_.wait_for(lock, std::chrono::seconds(1))) {
                            // 1s 后还是没任务 条件变量超时返回 检查如果线程空闲了 60s 那就回收掉
                            auto now = std::chrono::high_resolution_clock::now();
                            auto dur = std::chrono::duration_cast<std::chrono::seconds>(now - lastTime);
                            if (dur.count() >= THREAD_MAX_IDLE_TIME
                                && curThreadSize_ > initThreadSize_) {
                                // 开始回收当前线程
                                // 记录线程数量的相关变量的值修改
                                // 把线程对象从线程列表容器中回收 没有办法匹配 threadFunc 是哪一个 Thread 对象
                                // thread id => thread 对象 => 删除
                                threads_.erase(threadid);   // 不要 std::this_thread::get_id()
                                curThreadSize_--;
                                idleThreadSize_--;

                                std::cout << "threadid:" << std::this_thread::get_id() << "exit" << std::endl;
                                // 通知一下主线程
                                exitCond_.notify_all();
                                return;
                            }
                        }
                    } else {
                        notEmpty_.wait(lock);
                    }
                }

                if(!isPoolRunning_) {
                    break;
                }


                std::cout << "tid:"<< std::this_thread::get_id() << "获取任务成功..." << std::endl;
                // 取到任务减少空闲线程数量
                idleThreadSize_--;

                // 从任务队列中取一个任务出来
                task = taskQue_.front();
                taskQue_.pop();
                --taskSize_;

                // 如果依然有剩余任务，继续通知其他的线程执行任务
                if(!taskQue_.empty()) {
                    notEmpty_.notify_all();
                }

                // 取出一个任务，进行通知,通知可以继续提交生产任务
                notFull_.notify_all();
            }   // 取完任务就释放锁了，执行任务的时候不应该拿着锁占时间

            // 当前线程负责执行这个任务
            if(task != nullptr) {
                task(); // 执行function<void()>
            }
            // 执行完任务空闲了
            idleThreadSize_++;
            // 更新线程执行完任务的时间
            lastTime = std::chrono::high_resolution_clock::now();

        }

        // 结束线程池的时候正在执行任务，回来发现 isPoolRunning_ == false,就跳到这里
        threads_.erase(threadid);
        std::cout << "threadid:" << std::this_thread::get_id() << "exit" << std::endl;
        // 通知一下主线程
        exitCond_.notify_all();
   }

    /// 检查 pool 运行状态
    bool checkRunningState() const {
        return isPoolRunning_;
    }

private:
    std::unordered_map<int,std::unique_ptr<Thread>> threads_;   // 线程列表
    unsigned int initThreadSize_;                               // 初始线程数量
    std::atomic_uint curThreadSize_;                            // 记录当前线程池里面的线程数量
    unsigned int threadSizeThreshold_;                          // 线程数量上限阈值
    std::atomic_uint idleThreadSize_;                           // 记录空闲线程数量


	using Task = std::function<void()>;                         // Task任务 => 函数对象
	std::queue<Task> taskQue_;	                                // 任务队列
	std::atomic_uint taskSize_;                                 // 任务数量
	int taskQueMaxSizeThreshold_;                               // 任务队列数量上限的阈值


	std::mutex taskQueMtx_;                                     // 保证任务队列线程安全
	std::condition_variable notFull_;                           // 任务队列不满
	std::condition_variable notEmpty_;                          // 任务队列不空
    std::condition_variable exitCond_;                          // 等待线程资源全部回收


	PoolMode poolMode_;                                         // 当前线程池模式
    std::atomic_bool isPoolRunning_;                            // 表示线程池是否正在运行

};

```



```c++
#include "threadpool.hpp"
#include <iostream>
#include <chrono>
#include <thread>

using namespace std;

/*
一：如何让线程池提交任务更方便
    1.pool.submitTask(sum1, 10, 20);
      pool.submitTask(sum1, 10, 20);
      ***submitTask:可变参模板编程***
二：自己写的Result以及相关的类型，代码多
    c++11的线程库   thread
                   packaged_task(内部有get_future()方法可以获得任务返回值) <==>   function函数对象（需要自己进行封装）
                   future<int> res = task.get_future() <==> Result res = submitTask(); + 信号量的实现 + Any类实现
                   async
    ***使用future来替代Result 节省线程池代码***
*/
int sum1(int a, int b)
{
    return a + b;
}
int sum2(int a, int b, int c)
{
    return a + b + c;
}

int main()
{
    ThreadPool pool;
    pool.setMode(PoolMode::MODE_CACHED);
    pool.start(4);

    future<int> res1 = pool.submitTask(sum1, 1, 2);
    future<int> res2 = pool.submitTask(sum2, 1, 2, 3);
    future<int> res3 = pool.submitTask([](int begin, int end)->int {
        int sum = 0;
        for(int i = begin; i <= end; i++)
        {
            sum += i;
        }
        return sum;
    }, 1, 100);
    future<int> res4 = pool.submitTask(sum1, 1, 2);
    future<int> res5 = pool.submitTask(sum1, 1, 2);

    cout << res1.get() << endl;
    cout << res2.get() << endl;
    cout << res3.get() << endl;
    cout << res4.get() << endl;
    cout << res5.get() << endl;

}
```



### 单进程多线程的环境下， 三个线程协作，交替打印1-n个数字如何实现



### 手撕读写锁

```

```



### 事件驱动模型 epoll





## 实现智能指针

### 非线程安全版本



### 线程安全版本



## 汉诺塔

