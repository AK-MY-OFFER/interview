# 查找

## 线性表查找

### 顺序查找

$ASL=\frac {n+1} {2}$

优点：简单适用广，不用管是否有序

缺点：ASL 大

### 折半查找

只能用于顺序存储的**有序表**，不适合经常变动的

判定树：描述查找过程的二叉树，只与表记录个数n相关，与关键字取值无关

比较次数不超过判定树的深度：$\lfloor log_2n \rfloor+1$

如果不是满二叉树那么查找失败最少比较$\lfloor log_2n \rfloor$次，最多7比较$\lfloor log_2n \rfloor+1$次

$ASL=\frac {(n+1)log_2(n+1)}{n}-1$  约等于  $log_2(n+1)-1$



### 分块查找

又称索引序列查找

$ALS_{bs}=L_b+L_w$

$L_b$ 为所在块的平均查找长度

$L_w$ 为块中元素的平均查找长度

块的大小为 $\sqrt N$ 最合适



如果线性表既要快速查找又经常动态化，则可用分块查找

缺点是增加索引表的存储空间并对初始索引表排序





## 树表查找

### 二叉排序树

二叉排序树，又称二叉查找树、二叉搜索树。

二叉排序树是具有下列性质的二叉树：

若左子树不空，则左子树上所有结点的值均小于它的根结点的值；
若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；
左、右子树也分别为二叉排序树。


也就是说，二叉排序树中，左子树都比节点小，右子树都比节点大，递归定义。

根据二叉排序树这个特点我们可以知道，二叉排序树的中序遍历一定是从小到大的，比如上图，中序遍历结果是：

```
1 3 4 6 7 8 10 13 14
```

二叉排序树的性能取决于二叉树的层数：

- 最好的情况是 O(logn)，存在于完全二叉排序树情况下，其访问性能近似于折半查找；
- 最差时候会是 O(n)，比如插入的元素是有序的，生成的二叉排序树就是一个链表，这种情况下，需要遍历全部元素才行（见下图 b）。



#### 1.查找

根据二叉排序树的定义，我们可以知道在查找某个元素时：

- 先比较它与根节点，相等就返回；或者根节点为空，说明树为空，也返回；
- 如果它比根节点小，就从根的左子树里进行递归查找；
- 如果它比根节点大，就从根的右子树里进行递归查找。

可以看到，这就是一个 **二分查找**。

可以看到，在二叉排序树中查找是十分简单的，但是这依赖于每次插入、删除元素时对整个 排序树 结构的维护。



#### 2.插入

二叉树中的插入，主要分两步：查找、插入：

- 先查找有没有整个元素，有的话就不用插入了，直接返回；
- 没有就插入到之前查到（对比）好的合适的位置。

插入时除了设置数据，还需要跟父节点绑定，让父节点意识到有你这个孩子：比父节点小的就是左孩子，大的就是右孩子。



#### 3.删除 

插入操作和查找比较类似，而删除则相对复杂一点，需要根据删除节点的情况分类来对待：

如果要删除的节点正好是叶子节点，直接删除就 Ok 了；
如果要删除的节点还有子节点，就需要建立父节点和子节点的关系：
如果只有左孩子或者右孩子，直接把这个孩子上移放到要删除的位置就好了；
如果有两个孩子，就需要选一个合适的孩子节点作为新的根节点，该节点称为 继承节点。
新节点要求要比所有左子树大，比所有右子树小，怎么选择呢？

**要比所有左子树的值大、右子树小，就从右子树里找最小的好了；
同样也可以从左子树里找最大的。**

两种选择方法都可以，本文选用右子树里最小的节点，也就是右子树中最左边的节点。



### 红黑树

二叉排序树的性能取决于二叉树的层数：

最好的情况是 O(logn)，存在于完全二叉排序树情况下，其访问性能近似于折半查找；
最差时候会是 O(n)，比如插入的元素是有序的，生成的二叉排序树就是一个链表，这种情况下，需要遍历全部元素才行（见下图 b）。


为了改变排序二叉树存在的不足，Rudolf Bayer 在 1972 年发明了另一种改进后的排序二叉树：红黑树，他将这种排序二叉树称为“对称二叉 B 树”，而红黑树这个名字则由 Leo J. Guibas 和 Robert Sedgewick 于 1978 年首次提出。



红黑树本质上是一种二叉查找树，但它在二叉查找树的基础上额外添加了一个标记（颜色），同时具有一定的规则。这些规则使红黑树保证了一种平衡，插入、删除、查找的最坏时间复杂度都为 O(logn)。

它的统计性能要好于平衡二叉树（AVL树），因此，红黑树在很多地方都有应用。比如在 Java 集合框架中，很多部分(HashMap, TreeMap, TreeSet 等)都有红黑树的应用，这些集合均提供了很好的性能。



#### **黑色高度**

从根节点到叶节点的路径上黑色节点的个数，叫做树的黑色高度。



#### **红黑树的 5 个特性**

![shixinzhang](https://img-blog.csdn.net/20161123195416588)


红黑树在原有的二叉查找树基础上增加了如下几个要求：

* 每个节点要么是红色，要么是黑色；

* 根节点永远是黑色的；

* 所有的叶节点都是是黑色的（注意这里说叶子节点其实是上图中的 NIL 节点）；

* 每个红色节点的两个子节点一定都是黑色；

* 从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点；

	

注意：
性质 3 中指定红黑树的每个叶子节点都是空节点，而且并叶子节点都是黑色。但 Java 实现的红黑树将使用 null 来代表空节点，因此遍历红黑树时将看不到黑色的叶子节点，反而看到每个叶子节点都是红色的。

性质 4 的意思是：从每个根到节点的路径上不会有两个连续的红色节点，但黑色节点是可以连续的。
因此若给定黑色节点的个数 N，最短路径的情况是连续的 N 个黑色，树的高度为 N - 1;最长路径的情况为节点红黑相间，树的高度为 2(N - 1) 。

性质 5 是成为红黑树最主要的条件，后序的插入、删除操作都是为了遵守这个规定。

红黑树并不是标准平衡二叉树，它以性质 5 作为一种平衡方法，使自己的性能得到了提升。

#### 红黑树操作

红黑树的基本操作和其他树形结构一样，一般都包括查找、插入、删除等操作。前面说到，红黑树是一种自平衡的二叉查找树，既然是二叉查找树的一种，那么查找过程和二叉查找树一样，比较简单，这里不再赘述。相对于查找操作，红黑树的插入和删除操作就要复杂的多。尤其是删除操作，要处理的情况比较多，不过大家如果静下心来去看，会发现其实也没想的那么难。好了，废话就说到这，接下来步入正题吧。

##### **旋转操作**

在分析插入和删除操作前，这里需要插个队，先说明一下旋转操作，这个操作在后续操作中都会用得到。旋转操作分为左旋和右旋，左旋是将某个节点旋转为其右孩子的左孩子，而右旋是节点旋转为其左孩子的右孩子。这话听起来有点绕，所以还是请看下图：

![在这里插入图片描述](https://img-blog.csdnimg.cn/2019101517353917.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70)

上图包含了左旋和右旋的示意图，这里以右旋为例进行说明，右旋节点 M 的步骤如下：

1. 将节点 M 的左孩子引用指向节点 E 的右孩子
2. 将节点 E 的右孩子引用指向节点 M，完成旋转

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191015173550808.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70)

上面分析了右旋操作，左旋操作与此类似，大家有兴趣自己画图试试吧，这里不再赘述了。旋转操作本身并不复杂，这里先分析到这吧。

##### 插入

红黑树的插入过程和二叉查找树插入过程基本类似，不同的地方在于，红黑树插入新节点后，需要进行调整，以满足红黑树的性质。性质1规定红黑树节点的颜色要么是红色要么是黑色，那么在插入新节点时，这个节点应该是红色还是黑色呢？答案是红色，原因也不难理解。如果插入的节点是黑色，那么这个节点所在路径比其他路径多出一个黑色节点，这个调整起来会比较麻烦（参考红黑树的删除操作，就知道为啥多一个或少一个黑色节点时，调整起来这么麻烦了）。如果插入的节点是红色，此时所有路径上的黑色节点数量不变，仅可能会出现两个连续的红色节点的情况。这种情况下，通过变色和旋转进行调整即可，比之前的简单多了。

接下来，将分析插入红色节点后红黑树的情况。这里假设要插入的节点为 N，N 的父节点为 P，祖父节点为 G，叔叔节点为 U。插入红色节点后，会出现5种情况，分别如下：

**情况一**

插入的新节点 N 是红黑树的根节点，这种情况下，我们把节点 N 的颜色由红色变为黑色，性质2（根是黑色）被满足。同时 N 被染成黑色后，红黑树所有路径上的黑色节点数量增加一个，性质5（从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点）仍然被满足。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191015173604600.jpg)

**情况二**

N 的父节点是黑色，这种情况下，性质4（每个红色节点必须有两个黑色的子节点）和性质5没有受到影响，不需要调整。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191015173621779.jpg)

**情况三**

N 的父节点是红色（节点 P 为红色，其父节点必然为黑色），叔叔节点 U 也是红色。由于 P 和 N 均为红色，所有性质4被打破，此时需要进行调整。这种情况下，先将 P 和 U 的颜色染成黑色，再将 G 的颜色染成红色。此时经过 G 的路径上的黑色节点数量不变，性质5仍然满足。但需要注意的是 G 被染成红色后，可能会和它的父节点形成连续的红色节点，此时需要递归向上调整。

![在这里插入图片描述](https://img-blog.csdnimg.cn/2019101517363281.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70)

**情况四**

N 的父节点为红色，叔叔节点为黑色。节点 N 是 P 的右孩子，且节点 P 是 G 的左孩子。此时先对节点 P 进行左旋，调整 N 与 P 的位置。接下来按照情况五进行处理，以恢复性质4。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191015173643433.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70)

**情况五**

N 的父节点为红色，叔叔节点为黑色。N 是 P 的左孩子，且节点 P 是 G 的左孩子。此时对 G 进行右旋，调整 P 和 G 的位置，并互换颜色。经过这样的调整后，性质4被恢复，同时也未破坏性质5。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191015173653140.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70)

**插入总结**

上面五种情况中，情况一和情况二比较简单，情况三、四、五稍复杂。但如果细心观察，会发现这三种情况的区别在于叔叔节点的颜色，如果叔叔节点为红色，直接变色即可。如果叔叔节点为黑色，则需要选选择，再交换颜色。当把这三种情况的图画在一起就区别就比较容易观察了，如下图：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191015173703783.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70)

##### 删除

相较于插入操作，红黑树的删除操作则要更为复杂一些。删除操作首先要确定待删除节点有几个孩子，如果有两个孩子，不能直接删除该节点。而是要先找到该节点的前驱（该节点左子树中最大的节点）或者后继（该节点右子树中最小的节点），然后将前驱或者后继的值复制到要删除的节点中，最后再将前驱或后继删除。由于前驱和后继至多只有一个孩子节点，这样我们就把原来要删除的节点有两个孩子的问题转化为只有一个孩子节点的问题，问题被简化了一些。我们并不关心最终被删除的节点是否是我们开始想要删除的那个节点，只要节点里的值最终被删除就行了，至于树结构如何变化，这个并不重要。

红黑树删除操作的复杂度在于删除节点的颜色，当删除的节点是红色时，直接拿其孩子节点补空位即可。因为删除红色节点，性质5（从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点）仍能够被满足。当删除的节点是黑色时，那么所有经过该节点的路径上的黑节点数量少了一个，破坏了性质5。如果该节点的孩子为红色，直接拿孩子节点替换被删除的节点，并将孩子节点染成黑色，即可恢复性质5。但如果孩子节点为黑色，处理起来就要复杂的多。分为6种情况，下面会展开说明。

在展开说明之前，我们先做一些假设，方便说明。这里假设最终被删除的节点为`X`（至多只有一个孩子节点），其孩子节点为`N`，`X`的兄弟节点为`S`，`S`的左节点为 SL，右节点为 SR。接下来讨论是建立在节点 `X` 被删除，节点 `N` 替换`X`的基础上进行的。这里说明把被删除的节点`X`特地拎出来说一下的原因是防止大家误以为节点`N`会被删除，不然后面就会看不明白。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191015173717519.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70)

在上面的基础上，接下来就可以展开讨论了。红黑树删除有6种情况，分别是：

**情况一**

> N 是新的根。在这种情形下，我们就做完了。我们从所有路径去除了一个黑色节点，而新根是黑色的，所以性质都保持着。

上面是维基百科中关于红黑树删除的情况一说明，由于没有配图，看的有点晕。经过思考，我觉得可能会是下面这种情形：

要删除的节点 X 是根节点，且左右孩子节点均为空节点，此时将节点 X 用空节点替换完成删除操作。

可能还有其他情形，大家如果知道，烦请告知。

**情况二**

S 为红色，其他节点为黑色。这种情况下可以对 N 的父节点进行左旋操作，然后互换 P 与 S 颜色。但这并未结束，经过节点 P 和 N 的路径删除前有3个黑色节点（`P -> X -> N`），现在只剩两个了（`P -> N`）。比未经过 N 的路径少一个黑色节点，性质5仍不满足，还需要继续调整。不过此时可以按照情况四、五、六进行调整。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191015173732402.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70)

**情况三**

N 的父节点，兄弟节点 S 和 S 的孩子节点均为黑色。这种情况下可以简单的把 S 染成红色，所有经过 S 的路径比之前少了一个黑色节点，这样经过 N 的路径和经过 S 的路径黑色节点数量一致了。但经过 P 的路径比不经过 P 的路径少一个黑色节点，此时需要从情况一开始对 P 进行平衡处理。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191015173741748.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70)

**情况四**

N 的父节点为红色，叔叔节点为黑色。节点 N 是 P 的右孩子，且节点 P 是 G 的左孩子。此时先对节点 P 进行左旋，调整 N 与 P 的位置。接下来按照情况五进行处理，以恢复性质4。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191015173750267.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70)

这里需要特别说明一下，上图中的节点 N 并非是新插入的节点。当 P 为红色时，P 有两个孩子节点，且孩子节点均为黑色，这样从 G 出发到各叶子节点路径上的黑色节点数量才能保持一致。既然 P 已经有两个孩子了，所以 N 不是新插入的节点。情况四是由以 N 为根节点的子树中插入了新节点，经过调整后，导致 N 被变为红色，进而导致了情况四的出现。考虑下面这种情况（PR 节点就是上图的 N 节点）：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191015173800313.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70)

如上图，插入节点 N 并按情况三处理。此时 PR 被染成了红色，与 P 节点形成了连续的红色节点，这个时候就需按情况四再次进行调整。

**情况五**

S 为黑色，S 的左孩子为红色，右孩子为黑色。N 的父节点颜色可红可黑，且 N 是 P 左孩子。这种情况下对 S 进行右旋操作，并互换 S 和 SL 的颜色。此时，所有路径上的黑色数量仍然相等，N 兄弟节点的由 S 变为了 SL，而 SL 的右孩子变为红色。接下来我们到情况六继续分析。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191015173811796.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70)

**情况六**

S 为黑色，S 的右孩子为红色。N 的父节点颜色可红可黑，且 N 是其父节点左孩子。这种情况下，我们对 P 进行左旋操作，并互换 P 和 S 的颜色，并将 SR 变为黑色。因为 P 变为黑色，所以经过 N 的路径多了一个黑色节点，经过 N 的路径上的黑色节点与删除前的数量一致。对于不经过 N 的路径，则有以下两种情况：

1. 该路径经过 N 新的兄弟节点 SL ，那它之前必然经过 S 和 P。而 S 和 P 现在只是交换颜色，对于经过 SL 的路径不影响。
2. 该路径经过 N 新的叔叔节点 SR，那它之前必然经过 P、 S 和 SR，而现在它只经过 S 和 SR。在对 P 进行左旋，并与 S 换色后，经过 SR 的路径少了一个黑色节点，性质5被打破。另外，由于 S 的颜色可红可黑，如果 S 是红色的话，会与 SR 形成连续的红色节点，打破性质4（每个红色节点必须有两个黑色的子节点）。此时仅需将 SR 由红色变为黑色即可同时恢复性质4和性质5（从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。）。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191015173822406.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70)

**删除总结**

红黑树删除的情况比较多，大家刚开始看的时候可能会比较晕。可能会产生这样的疑问，为啥红黑树会有这种删除情况，为啥又会有另一种情况，它们之间有什么联系和区别？和大家一样，我刚开始看的时候也有这样的困惑，直到我把所有情况对应的图形画在一起时，拨云见日，一切都明了了。此时天空中出现了4个字，原来如此、原来如此、原来如此。所以，请看图吧：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191015173832537.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70)





#### 问题

红黑树比普通二叉树优点

红黑树怎么自平衡

### 平衡二叉树

* 左右子树深度差绝对值不超过 1

* 左右子树都是平衡二叉树

* 平衡因子 BF ：-1、0、1



调整方法：找到离插入结点最近且平衡因子绝对值超过1的祖先结点，以该结点为根的子树称为最小不平衡子树
LL 型，RR 型，LR 型，RL 型,自己会弄就行了





### B 树

* 适用于文件很大且放于外存的查找
* B-树 是 m叉平衡排序树
* 应用于磁盘中的目录管理，数据库系统中的索引组织



一棵 m 阶的 B-树，或为空树，或为满足下列特性的m叉树

* 关键字数量=子树数量-1
* 树中的每个结点至多有 m 棵子树
* 所有的非终端结点最多有 m-1 个关键字
* 若根节点不是叶子结点，则至少有两棵子树，至少有一个关键字
* 除根之外的所有非终端结点至少有 $\lfloor m/2\rfloor$ 棵子树，至少有 $\lfloor m/2\rfloor-1$个关键字
* 所有的叶子结点出现在同层次（体现平衡），不带任何信息，称为失败结点（实际不存在）
* 任一关键字 $K_i$ ，$P_{i-1}$ 指向左子树，$P_i$ 指向右子树
* **B-树 具有平衡、有序、多路的特点**
* 根节点数据有序

插入删除记住以下几点

* **除根节点外，结点中关键字范围$\lceil m/2 \rceil-1到m-1$**
* **B-树的新关键字总是落在终端结点**
* 要永远保证 子树0<关键字1<子树1<关键字2<子树3……
* 所有叶节点在同一层

 **B-树 查找**

* 包含两种基本操作：在 B-树 中查找结点(磁盘），在结点中查找关键字（内存）
* 磁盘上查找时间>内存上查找时间
* 只支持随机查找
* 在磁盘上进行查找的次数，即查找关键字结点在 B- 树上的层数，是决定B-树查找效率的首要因素
* 在含有 N 个关键字的 B- 树上查找时，从根到关键字所在结点的路径上涉及的结点个数不超过 $log_{\lceil m/2\rceil}{\frac {N+1} 2}+1$



### B+ 树

B+树 是 B-树 的变形，更适合文件索引系统

B+树 和 B-树 的差异如下

* 有 n 棵子树的结点含有 n 个关键字
* 所有的叶子结点包含了全部关键字的内容，以及指向这些关键字记录的指针，且叶子结点本身依关键字的大小自小到大顺序链接
* 所有非终端结点可以看作索引部分，结点中仅含有子树（根节点）中的最大（最小）关键字
* 叶节点之间指针链接



查找：

* 可以对B+树进行两种查找，一种从最小关键字起**顺序查找**（B-S树 不支持），另一种从根节点开始**随机查找**
* B+树不仅能够有效地查找单个关键字，更适合查找某个范围内所有关键字



插入：

* 只在叶子结点插入

* 结点关键字个数>m就分裂，分别包含$\lfloor \frac {m+1} 2\rfloor$和$\lceil \frac {m+1} 2\rceil$,双亲结点应该同时包含两个的最大关键字

	

删除：

* 只在叶子结点进行



#### 前缀树





## 哈希表

#### 散列函数构造方法

通常考虑下面要素

* 散列表的长度
* 关键字的长度
* 关键字的分布情况
* 计算散列函数的所需的时间
* 记录的查找效率



好的散列函数

* 函数计算阶段，每个关键字只有一个散列地址与之对应
* 函数的值域要在表长范围内，分布尽量均匀，尽可能减少冲突



* 数字分析法：事先必须明确知道所有的关键字每一位上各种数字的分布情况
* 平方取中法：
	* 取关键字平方后的中间几位或组合作为散列地址，具体所取的位数由表长决定
	* 适合不能事先了解关键字的所有情况或难以从关键字中找到取值较分散的几位

* 折叠法：
	* 将关键字分割成位数相同的及部分（最后一部分可以不同），然后取基本法叠加和（舍去进位）作为散列地址
	* 有移位叠加和边界叠加两种
	* 适合散列地址位数较少，关键字位数较多，且难于直接从关键字中取值分散的几位

* 除留余数法：$H(key)=key%p$，假设散列表长为m,选一个不大于m的数p,用p去除关键字，p一般为小于表长的最大质数





### 冲突处理

**开放地址法：寻找下一个空的散列地址（探测）**

$H_i=(H(key)+d_i)\% m$

$d_i$为增量序列，根据增量序列的不同分为下面三种探测方法

* 线性探测法：

​	$d_i=1,2,……,m$

​	把散列表想成循环表，总能找到一个不发生冲突的，如果找不到就是满了，要做溢出处理
​	会产生二次聚集。可能要探测多个位置，这些位置的关键字不一定都是同义词

* 二次探测法：

​	$d_i=1^2,-1^2,2^2,-2^2,3^2,-3^2,……,k^2,-k^2$

​	$k<=m/2$

​	可以避免二次聚集，但是不能保证找到不发生冲突的地址

* 伪随机探测法

	$d_i=伪随机数序列$

	可以避免二次聚集，但是不能保证找到不发生冲突的地址

​	

二次聚集：处理冲突中发生的两个第一个散列地址不同的记录争夺同一个后继散列地址的现象



**链地址法**

* 同义词接在相同的链表里
* 查找一个元素的时间是不同的
* 避免了二次聚集





**再散列**

发生冲突时使用另一种hash函数再计算一个地址，直到不冲突



**公共溢出区**

一旦hash函数计算的结果相同，就放入公共溢出区



### 负载因子

### 哈希表满了怎么办

并行哈希

