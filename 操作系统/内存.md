# 内存

## 问题

### 虚拟内存机制

* 为什么要虚拟内存，有什么用？
* 如何实现虚拟内存？
	* 硬件支持
	* 软件支持

* 谈谈内存分段？
  * 什么是内存分段
  * 分段机制下，虚拟地址和物理地址是如何映射的？
  * 分段的优点
  * 分段的缺点及解决方案
* 谈谈内存分页？
  * 什么是内存分页
  * 分页机制下，虚拟地址和物理地址是如何映射的？
  * 分页的优点
  * 分页的缺点及解决方案
* 谈谈段页式内存管理
	* 什么是内存分页
	* 分页机制下，虚拟地址和物理地址是如何映射的？
	* 分页的优点
	* 分页的缺点及解决方案


### malloc 和 free

* malloc 如何分配内存？
* malloc 分配的是物理内存吗？
* malloc(1) 会分配多大内存？
* malloc() 为什么不全部使用 mmap 来分配内存？
* mmap 实现原理？
* malloc() 为什么不全部使用 brk 来分配内存？
* malloc() 如果没有成功，可能什么原因，计算机会做什么？
* malloc() 线程安全机制 ?
* free 释放内存，会归还给操作系统吗？
* free() 函数只传入一个内存地址，为什么会知道要释放多大的内存？
* 被free() 回收的内存是立即返还给操作系统吗？

### 内存分配算法

* 首次适配算法？
* 最佳适应算法？
* 最差适应算法？
* buddy 伙伴算法
* slab 算法？



## 回答

### 虚拟内存机制

#### 为什么要虚拟内存，有什么用？

单片机是没有操作系统的，所以每次写完代码，都需要借助工具把程序烧录进去，这样程序才能跑起来。

另外，**单片机的 CPU 是直接操作内存的「物理地址」**。

![img](https://img-blog.csdnimg.cn/019f1f0d2d30469cbda2b8fe2cf5e622.png)

在这种情况下，要想在内存中同时运行两个程序是不可能的。如果第一个程序在 2000 的位置写入一个新的值，将会擦掉第二个程序存放在相同位置上的所有内容，所以同时运行两个程序是根本行不通的，这两个程序会立刻崩溃。

> 操作系统是如何解决这个问题呢？

这里关键的问题是这两个程序都引用了绝对物理地址，而这正是我们最需要避免的。

我们可以把进程所使用的地址「隔离」开来，即让操作系统为每个进程分配独立的一套「**虚拟地址**」，人人都有，大家自己玩自己的地址就行，互不干涉。但是有个前提每个进程都不能访问物理地址，至于虚拟地址最终怎么落到物理内存里，对进程来说是透明的，操作系统已经把这些都安排的明明白白了。

![进程的中间层](https://img-blog.csdnimg.cn/img_convert/298fb68e3da94d767b02f2ed81ebf2c4.png)

**操作系统会提供一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来。**

如果程序要访问虚拟地址的时候，由操作系统转换成不同的物理地址，这样不同的进程运行的时候，写入的是不同的物理地址，这样就不会冲突了。

于是，这里就引出了两种地址的概念：

- 我们程序所使用的内存地址叫做**虚拟内存地址**（*Virtual Memory Address*）
- 实际存在硬件里面的空间地址叫**物理内存地址**（*Physical Memory Address*）。

操作系统引入了虚拟内存，进程持有的虚拟地址会通过 CPU 芯片中的内存管理单元（MMU）的映射关系，来转换变成物理地址，然后再通过物理地址访问内存，如下图所示：

![img](https://img-blog.csdnimg.cn/72ab76ba697e470b8ceb14d5fc5688d9.png)

**虚拟内存的作用**

- 第一，虚拟内存可以使得进程的运行内存超过物理内存大小，因为程序运行符合局部性原理，CPU 访问内存会有很明显的重复访问的倾向性，对于那些没有被经常使用到的内存，我们可以把它换出到物理内存之外，比如硬盘上的 swap 区域。
- 第二，由于每个进程都有自己的页表，所以每个进程的虚拟内存空间就是相互独立的。进程也没有办法访问其他进程的页表，所以这些页表是私有的，这就解决了多进程之间地址冲突的问题。
- 第三，页表里的页表项中除了物理地址之外，还有一些标记属性的比特，比如控制一个页的读写权限，标记该页是否存在等。在内存访问方面，操作系统提供了更好的安全性。
