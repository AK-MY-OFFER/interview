# 面向对象

## 问题

### 基本认识

* 简述一下什么是面向对象
* 面向对象三大特征
* 什么是多态？除了虚函数，还有什么方式能实现多态？
* 简述一下 C++ 中的多态
* 简述下向上转型和向下转型
* 简述下深拷贝和浅拷贝，如何实现深拷贝
* 多继承的优缺点，作为一个开发者怎么看待多继承
* 什么是虚拟继承
* 说说 C 语言如何实现 C++ 语言中的重载
* 说说 C++ 的重载和重写是如何实现的

* 简述一下 C++ 的重载和重写，以及它们的区别？







### 类

* 类中 static 作用？

* 解释下 C++ 中类模板和模板类的区别？

* 说说什么是虚基类，可否被实例化？

* 如何理解抽象类？

* 说说类方法和数据的权限有哪几种？

* 说说 C++ 中什么是菱形继承问题，如何解决？

* 说说什么是虚继承，解决什么问题，如何实现？

* 请你回答一下 C++ 类内可以定义引用数据成员吗？

* 说说类继承时，派生类对不同关键字修饰的基类方法的访问权限？

* 说说 C++ 类对象的初始化顺序，有多重继承情况下的顺序

* 抽象基类为什么不能创建对象？

	

### 特殊成员函数

* 构造函数、析构函数具体的执行过程？
* 说说一个空类，默认会生成哪些函数？

* 什么情况会自动生成默认构造函数？
* 什么时候需要合成拷贝构造函数呢？
* 三之法则/五之法则/零之法则？
* 为什么拷贝构造函数必须传引用不能传值？

* 简述一下移动构造函数？

* 构造函数、拷贝构造函数和赋值操作符的区别？

* 简述一下拷贝赋值和移动赋值？

* 构造函数的几种关键字

* 构造函数和析构函数可否抛出异常

* 说说构造函数有几种，分别什么作用(感觉答案有点离谱）

* 析构函数的作用，如何起作用，类什么时候会析构

	

### 虚函数

* C++ 中哪些函数不能被声明为虚函数？

* 虚析构函数的作用？

* 虚函数的代价？

* 虚函数表放在内存的什么区，其中的内容什么时候写进去的，虚表指针初始化时间，怎么查找虚函数的？

* 说说C++中虚函数与纯虚函数？

* 构造函数或析构函数中可以调用虚函数吗

	



## 回答

### 特殊成员函数

#### 谈谈构造函数、析构函数的作用、特点、具体过程、异常

**构造函数**

作用

构造函数只是起初始化值的作用，但实例化一个对象的时候，可以通过实例去传递参数，从主函数传递到其他的函数里面，这样就使其他的函数里面有值了。规则，只要你一实例化对象，系统自动回调用一个构造函数就是你不写，编译器也自动调用一次。



构造函数顺序

① 基类构造函数。如果有多个基类，则构造函数的调用顺序是某类在类派生表中出现的顺序，而不是它们在成员初始化表中的顺序。

② 成员类对象构造函数。如果有多个成员类对象则构造函数的调用顺序是对象在类中被声明的顺序，而不是它们出现在成员初始化表中的顺序。

③ 派生类构造函数。

1. 对象的vptr被初始化；
2. 如果有成员初始化列表，将在构造函数体内扩展开来，这必须在vptr被设定之后才做；
3. 执行程序员所提供的代码；



C++构造函数的调用次序是：

基类的成员->基类的构造函数体->派生类的成员->派生类的构造函数体



几种关键字

* default 关键字可以显式要求编译器生成合成构造函数，防止在调用时相关构造函数类型没有定义而报错
* delete 关键字可以删除构造函数、赋值运算符函数等，这样在使用的时候会得到友善的提示



C++中的构造函数可以分为4类：

* 默认构造函数：有了有参的构造了，编译器就不提供默认的构造函数
* 初始化构造函数
* 拷贝构造函数：赋值构造函数默认实现的是值拷贝（浅拷贝）
* 移动构造函数

 



**析构函数** 

析构函数与构造函数的作用相反，用于撤销对象的一些特殊任务处理，可以是释放对象分配的内存空间；特点：析构函数与构造函数同名，但该函数前面加~。

析构函数没有参数，也没有返回值，而且不能重载，在一个类中只能有一个析构函数。 当撤销对象时，编译器也会自动调用析构函数。

每一个类必须有一个析构函数，用户可以自定义析构函数，也可以是编译器自动生成默认的析构函数。一般析构函数定义为类的公有成员。



类会在下面的情况析构

* 对象生命周期结束，被销毁时；
* delete指向对象的指针时，或delete指向对象的基类类型指针，而其基类虚构函数是虚函数时
*  对象i是对象o的成员，o的析构函数被调用时，对象i的析构函数也被调用。



 

析构函数顺序

1. 调用派生类的析构函数；
2. 调用成员类对象的析构函数；
3. 调用基类的析构函数。
4. 基类的成员析构



C++析构函数的调用次序是：

派生类的析构函数->派生类的成员析构->基类的析构函数->基类的成员析构



**是否能抛出异常**

* C++只会析构已经完成的对象，对象只有在其构造函数执行完毕才算是完全构造妥当。在构造函数中发生异常，控制权转出构造函数之外。因此，在对象b的构造函数中发生异常，对象b的析构函数不会被调用。因此会造成内存泄漏。
* 用auto_ptr对象来取代指针类成员，便对构造函数做了强化，免除了抛出异常时发生资源泄漏的危机，不再需要在析构函数中手动释放资源；
* 如果控制权基于异常的因素离开析构函数，而此时正有另一个异常处于作用状态，C++会调用terminate函数让程序结束；
* 如果异常从析构函数抛出，而且没有在当地进行捕捉，那个析构函数便是执行不全的。如果析构函数执行不全，就是没有完成他应该执行的每一件事情。



#### 说说一个空类，默认会生成哪些函数?

**声明时[编译器](https://so.csdn.net/so/search?q=编译器&spm=1001.2101.3001.7020)不会生成任何成员函数**

对于空类，声明时，编译器不会生成任何的成员函数，只会生成1个字节的占位符。
有时可能会以为编译器会为空类生成默认[构造函数](https://so.csdn.net/so/search?q=构造函数&spm=1001.2101.3001.7020)等，事实上是不会的，编译器只会在需要的时候生成6个成员函数：一个缺省的构造函数、一个拷贝构造函数、一个析构函数、一个赋值运算符、一对取址运算符和一个this指针
代码：

```c++
#include <iostream>
using namespace std;
 
class Empty_one {};
class Empty_two {};
class Empty_three {
    virtual void fun() = 0;//虚函数
};
class Empty_four :  public Empty_two, public Empty_three {};
 
int main() {
  cout<<"sizeof(Empty_one):"<<sizeof(Empty_one)<<endl;
  cout<<"sizeof(Empty_two):"<<sizeof(Empty_two)<<endl;
  cout<<"sizeof(Empty_three):"<<sizeof(Empty_three)<<endl;//有一个虚指针
  cout<<"sizeof(Empty_four):"<<sizeof(Empty_four)<<endl;
  return 0;
}

```

运行结果：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190314151000624.png)



分析：

* 类Empty_one、Empty_two是空类，但空类同样可以被实例化，而每个实例在内存中都有一个独一无二的地址，为了达到这个目的，**编译器往往会给一个空类隐含的加一个字节**，这样空类在实例化后在内存得到了独一无二的地址，所以sizeof(Empty_one)和sizeof(Empty_two)的大小为1。
* 类Empty_three里面因有一个纯虚函数，故有一个指向虚函数的指针（vptr），64位系统分配给指针的大小为8个字节，所以sizeof(Empty_three)的大小为8。
* 类Empty_four继承于Empty_two和Empty_three，编译器取消Empty_two的占位符，保留一虚函数表，故大小为8。



**空类定义时会生成6个成员函数**

当空类Empty_one定义一个对象时Empty_one pt;sizeof(pt)仍是为1，但编译器会生成6个成员函数：

* 缺省的构造函数（无参）
* 拷贝构造函数
* 析构函数（非虚）
* 赋值运算符
* 两个取址运算符

```c++
class Empty
{
  public:
    Empty();                            //缺省构造函数
    Empty(const Empty &rhs);            //拷贝构造函数
    ~Empty();                           //析构函数 
    Empty& operator=(const Empty &rhs); //赋值运算符
    Empty* operator&();                 //取址运算符
    const Empty* operator&() const;     //取址运算符(const版本)
};

Empty *e = new Empty();    //缺省构造函数
delete e;                  //析构函数
Empty e1;                  //缺省构造函数                               
Empty e2(e1);              //拷贝构造函数
e2 = e1;                   //赋值运算符
Empty *pe1 = &e1;          //取址运算符(非const)
const Empty *pe2 = &e2;    //取址运算符(const)
```





#### 什么情况会自动生成默认构造函数？

* 如果一个类没有任何构造函数，但他含有一个成员对象，该成员对象含有默认构造函数，那么编译器就为该类合成一个默认构造函数，因为不合成一个默认构造函数那么该成员对象的构造函数不能调用；不过这个合成操作只有在构造函数真正被需要的时候才会发生；如果一个类A含有多个成员类对象的话，那么类A的每一个构造函数必须调用每一个成员对象的默认构造函数而且必须按照类对象在类A中的声明顺序进行；
* 没有任何构造函数的类派生自一个带有默认构造函数的基类，那么需要为该派生类合成一个构造函数，只有这样基类的构造函数才能被调用；
* 带有虚函数的类，虚函数的引入需要进入虚表，指向虚表的指针，该指针是在构造函数中初始化的，所以没有构造函数的话该指针无法被初始化；
* 带有一个虚基类的类



需要注意的是：

* 默认构造不一定是合成的，也可以是用户自定义的

* 并不是任何没有构造函数的类都会合成一个构造函数
* 编译器合成出来的构造函数并不会显示设定类内的每一个成员变量
* 合成的默认构造函数中，只有基类子对象和成员类对象会被初始化。所有其他的非静态数据成员都不会被初始化。





#### 什么时候需要合成拷贝构造函数呢？

有三种情况会以一个对象的内容作为另一个对象的初值：

* 对一个对象做显示的初始化操作，X xx = x；
* 当对象被当做参数交给某个函数时；
* 当函数传回一个类对象时；

 

*  如果一个类没有拷贝构造函数，但是含有一个类类型的成员变量，该类型含有拷贝构造函数，此时 编译器会为该类合成一个拷贝构造函数；

* 如果一个类没有拷贝构造函数，但是该类继承自含有拷贝构造函数的基类，此时编译器会为该类合成一个拷贝构造函数；

* 如果一个类没有拷贝构造函数，但是该类声明或继承了虚函数，此时编译器会为该类合成一个拷贝 构造函数；

	如果一个类没有拷贝构造函数，但是该类含有虚基类，此时编译器会为该类合成一个拷贝构造函 数；



#### 三/五/零之法则

三之法则：如果某个类需要用户定义的析构函数、用户定义的复制构造函数或用户定义的复制赋值运算符，那么它几乎肯定需要全部三者。（只定义了析构函数，编译器将自动为我们生成拷贝构造函数和默认构造函数。）

五之法则：任何想要移动语义的类必须声明全部五个特殊成员函数 (析构函数、拷贝构造、赋值运算、移动拷贝构造、移动赋值运算)：

零之法则：有自定义析构函数、复制/移动构造函数或复制/移动赋值运算符的类应该专门处理所有权

当有意将某个基类用于多态用途时，可能需要将它的析构函数声明为公开的虚函数。由于这会阻拦隐式移动（并弃用隐式复制）的生成，因而必须将各特殊成员函数声明为预置的





#### 为什么拷贝构造函数必须传引用不能传值？

拷贝构造函数的参数必须使用引用传递

如果拷贝构造函数中的参数不是一个引用，即形如CClass(const CClass c_class)，那么就相当于采用了传值的方式(pass-by-value)，而传值的方式会调用该类的拷贝构造函数，从而造成无穷递归地调用拷贝构造函数。因此拷贝构造函数的参数必须是一个引用。

需要澄清的是，传指针其实也是传值，如果上面的拷贝构造函数写成Class(const CClass* c_class)，也是不行的。事实上，只有传引用不是传值外，其他所有的传递方式都是传值。



#### 简述一下移动构造函数？

* 有时候我们会遇到这样一种情况，我们用对象a初始化对象b后对象a我们就不在使用了，但是对象a的空间还在呀（在析构之前），既然拷贝构造函数，实际上就是把a对象的内容复制一份到b中，那么为什么我们不能直接使用a的空间呢？这样就避免了新的空间的分配，大大降低了构造的成本。这就是移动构造函数设计的初衷；
* 拷贝构造函数中，对于指针，我们一定要采用深层复制，而移动构造函数中，对于指针，我们采用浅层复制；
* C++引入了移动构造函数，专门处理这种，用a初始化b后，就将a析构的情况；
* 与拷贝类似，移动也使用一个对象的值设置另一个对象的值。但是，又与拷贝不同的是，移动实现的是对象值真实的转移（源对象到目的对象）：源对象将丢失其内容，其内容将被目的对象占有。移动操作的发生的时候，是当移动值的对象是未命名的对象的时候。这里未命名的对象就是那些临时变量，甚至都不会有名称。典型的未命名对象就是函数的返回值或者类型转换的对象。使用临时对象的值初始化另一个对象值，不会要求对对象的复制：因为临时对象不会有其它使用，因而，它的值可以被移动到目的对象。做到这些，就要使用移动构造函数和移动赋值：当使用一个临时变量对象进行构造初始化的时候，调用移动构造函数。类似的，使用未命名的变量的值赋给一个对象时，调用移动赋值操作；



```c++
Example6 (Example6&& x) : ptr(x.ptr) {
    x.ptr = nullptr;
}

// move assignment
Example6& operator= (Example6&& x) {
   delete ptr; 
   ptr = x.ptr;
   x.ptr=nullptr;
    return *this;
}
```





#### 构造函数、拷贝构造函数和赋值操作符的区别

**构造函数**

对象不存在，没用别的对象初始化，在创建一个新的对象时调用构造函数

**拷贝构造函数**

对象不存在，但是使用别的已经存在的对象来进行初始化

**赋值运算符**

对象存在，用别的对象给它赋值，这属于重载“=”号运算符的范畴，“=”号两侧的对象都是已存在的



- 拷贝构造函数是函数，赋值运算符是运算符重载。
- 拷贝构造函数会生成新的类对象，赋值运算符不能。
- 拷贝构造函数是直接构造一个新的类对象，所以在初始化对象前不需要检查源对象和新建对象是否相同；赋值运算符需要上述操作并提供两套不同的复制策略，另外赋值运算符中如果原来的对象有内存分配则需要先把内存释放掉。
- 形参传递是调用拷贝构造函数（调用的被赋值对象的拷贝构造函数），但并不是所有出现"="的地方都是使用赋值运算符，如下：

注：类中有指针变量时要重写析构函数、拷贝构造函数和赋值运算符。



举个例子：

```c++
#include <iostream>
using namespace std;

class A {
public:
    A() { cout << "我是构造函数" << endl; }
    A(const A& a) { cout << "我是拷贝构造函数" << endl;}
    A& operator = (A& a) {
        cout << "我是赋值操作符" << endl;
        return *this;
    }
    ~A() {};
};

int main() {
    A a1; //调用构造函数
    A a2 = a1; //调用拷贝构造函数
    a2 = a1; //调用赋值操作符
    return 0;
}
//输出结果
//我是构造函数
//我是拷贝构造函数
//我是赋值操作符
```











### 虚函数

#### 哪些函数不能是虚函数？

常见的不能声明为虚函数的有：

* 普通函数（非成员函数）
* 静态成员函数
* 内联成员函数
* 构造函数
* 友元函数。



**为什么C++不支持普通函数为虚函数？**

   普通函数（非成员函数）只能被overload，不能被override，声明为虚函数也没有什么意思，因此编译器会在编译时绑定函数。



**为什么C++不支持构造函数为虚函数？**

这个原因很简单，主要是从语义上考虑，所以不支持。因为构造函数本来就是为了明确初始化对象成员才产生的，然而virtual function主要是为了再不完全了解细节的情况下也能正确处理对象。另外，virtual函数是在不同类型的对象产生不同的动作，现在对象还没有产生，如何使用virtual函数来完成你想完成的动作。（这不就是典型的悖论）

构造函数用来创建一个新的对象,而虚函数的运行是建立在对象的基础上,在构造函数执行时,对象尚未形成,所以不能将构造函数定义为虚函数



1. 从存储空间角度：虚函数对应一个vtale,这个表的地址是存储在对象的内存空间的。如果将构造函数设置为虚函数，就需要到vtable 中调用，可是对象还没有实例化，没有内存空间分配，如何调用。（悖论）
2. 从使用角度：虚函数主要用于在信息不全的情况下，能使重载的函数得到对应的调用。构造函数本身就是要初始化实例，那使用虚函数也没有实际意义呀。所以构造函数没有必要是虚函数。虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。
3. 从实现上看，vbtl 在构造函数调用后才建立，因而构造函数不可能成为虚函数。从实际含义上看，在调用构造函数时还不能确定对象的真实类型（因为子类会调父类的构造函数）；而且构造函数的作用是提供初始化，在对象生命期只执行一次，不是对象的动态行为，也没有太大的必要成为虚函数。

 

**为什么C++不支持内联成员函数为虚函数？**

其实很简单，那内联函数就是为了在代码中直接展开，减少函数调用花费的代价，虚函数是为了在继承后对象能够准确的执行自己的动作，这是不可能统一的。（再说了，*inline函数在编译时被展开，虚函数在运行时才能动态的绑定函数*）

内联函数是在编译时期展开,而虚函数的特性是运行时才动态联编,所以两者矛盾,不能定义内联函数为虚函数

 

**为什么C++不支持静态成员函数为虚函数？**

这也很简单，静态成员函数对于每个类来说只有一份代码，所有的对象都共享这一份代码，他也没有要动态绑定的必要性。

静态成员函数属于一个类而非某一对象,没有this指针,它无法进行对象的判别

 

**为什么C++不支持友元函数为虚函数？**

因为C++不支持友元函数的继承，对于没有继承特性的函数没有虚函数的说法。



#### 虚析构函数的作用

虚析构函数，是将基类的析构函数声明为virtual，举例如下：

```cpp
class TimeKeeper
{
public:    
    TimeKeeper() {}        
    virtual ~TimeKeeper() {}    
};
```

 

**虚析构函数的主要作用是防止内存泄露。**

定义一个基类的指针p，在delete p时，如果基类的析构函数是虚函数，这时只会看p所赋值的对象，如果p赋值的对象是派生类的对象，就会调用派生类的析构函数（毫无疑问，在这之前也会先调用基类的构造函数，在调用派生类的构造函数，然后调用派生类的析构函数，基类的析构函数，所谓先构造的后释放）；如果p赋值的对象是基类的对象，就会调用基类的析构函数，这样就不会造成内存泄露。

如果基类的析构函数不是虚函数，在delete p时，调用析构函数时，只会看指针的数据类型，而不会去看赋值的对象，这样就会造成内存泄露。



1. 虚析构：将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。如果基类的析构函数不是虚函数，在特定情况下会导致派生来无法被析构。
	1. 用派生类类型指针绑定派生类实例，析构的时候，不管基类析构函数是不是虚函数，都会正常析构
	2. 用基类类型指针绑定派生类实例，析构的时候，如果基类析构函数不是虚函数，则只会析构基类，不会析构派生类对象，从而造成内存泄漏。为什么会出现这种现象呢，个人认为析构的时候如果没有虚函数的动态绑定功能，就只根据指针的类型来进行的，而不是根据指针绑定的对象来进行，所以只是调用了基类的析构函数；如果基类的析构函数是虚函数，则析构的时候就要根据指针绑定的对象来调用对应的析构函数了。

C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。



#### 虚函数的代价

* 带有虚函数的类，每一个类会产生一个虚函数表，用来存储指向虚成员函数的指针，增大类；

* 带有虚函数的类的每一个对象，都会有有一个指向虚表的指针，会增加对象的空间大小；

* 虚函数难以内联，因为内联函数在编译阶段进行替代，而虚函数在运行阶段才能确定到底是采用哪种函数，虚函数一般不是内联函数。

* Cache命中率不够好，一般函数可能编译后的指令就在当前函数地址附近，这样很可能在调用前目标函数代码已经被载入指令cache. 但是虚拟函数不在cache中的概率高。而且一调函数就可能在cache中载入虚函数表，如果这个虚函数又调用其它的虚函数，那么可能又得载入到cache中导致cache被占用，指令和数据的cache命中率下降

* 编译器不好优化。因为编译器只知道你要调用的是一个不确定的地址处的函数，没法知道更多细节，也就没法替你做更多优化

* 查找虚表有一定损耗（影响小）




#### 虚函数表放在内存的什么区，其中的内容什么时候写进去的，虚表指针初始化时间，怎么查找虚函数的？

结论

虚表：

* 编译时构造完成，在构造函数执行之前
* 存储在只读数据段（.rodata)，也就是内存模型中的常量区

虚表指针：

* 在对类进行实例化，构造函数执行时对虚表指针进行初始化
* 存储在对象内存布局最前面，位于代码段(.text) ，也就是内存模型中的代码去

查找过程：

1.编译器会给每个虚函数指定一个在[虚函数表](https://www.zhihu.com/search?q=虚函数表&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1520718705})中的索引

2.在编译期，虚函数的调用以及被类似转化成`(*p->vptr[1])(p)` 这种形式，前面获取到func1的地址，然后调用，传的参数是p（表示this指针）。（假设func1函数是在索引1的位置，实际上从书中得知，虚函数表的第0位置存放的是type_info，虚函数都是从索引1的位置开始）

有人会问，虚函数调用在编译期转换成了`(*p->vptr[1])(p)` 这种形式，那岂不是写死了调用的是哪一个函数？但是在运行期才知道是调用的是基类还是子类的函数啊？  

这个问题其实是不存在的， `(*p->vptr[1])(p)` 这样只是在运行时告诉CPU，要去虚函数表索引为1的地方读取函数地址，这个函数的地址却不是编译期能确定的，因为可以b指针可以指向父类也可以指向子类。所以在运行时，  `vptr[1]`的值是根据运行时的具体指针指向情况确定的。 只不过，在编译期时已经确定了虚函数表中的每一项对应了每一个固定的虚函数。

例如例子中Base对象：

- Base对象的 func1 函数在虚函数表中的索引值是1
- Base对象的func2函数在虚函数表中的索引值是2

Child对象：

- func1函数在虚函数表中的索引值还是1.  继承自Base
- func2索引值还是2    继承自Base
- func3索引值是3    自己的虚函数

由上可见，其实无论是Base对象还是Child对象，虚函数 func1 在各自的虚函数表中的索引都是1.

**因此编译器便能把虚函数的调用在编译期就能直接替换成`(*p->vptr[1])(p)`这种形式**。

只不过如果指针指向的是Base对象，那么内存布局就是Base对象的内存，那么虚函数表中的vptr[1]存放的是Base自己的func1的地址；而如果指针指向的是Child对象，内存布局就是Child对象的内存，那么虚函数表中的vptr[1]存放的就是Child的func1函数的地址。



**分析**

虚函数表是全局共享的元素，即全局仅有一个，**在编译时就构造完成**

虚函数表类似一个数组，类对象中存储vptr指针，指向虚函数表，即虚函数表不是函数，不是程序代码，不可能存储在代码段

虚函数表存储虚函数的地址,即虚函数表的元素是指向类成员函数的指针,而类中虚函数的个数在编译时期可以确定，即虚函数表的大小可以确定,即大小是在编译时期确定的，不必动态分配内存空间存储虚函数表，所以不在堆中

根据以上特征，虚函数表类似于类中静态成员变量.静态成员变量也是全局共享，大小确定，因此最有可能存在全局数据区，测试结果显示：

虚函数表vtable在Linux/Unix中存放在可执行文件的只读数据段中(rodata)，这与微软的编译器将虚函数表存放在常量段存在一些差别

由于虚表指针vptr跟虚函数密不可分，对于有虚函数或者继承于拥有虚函数的基类，**对该类进行实例化时，在构造函数执行时会对虚表指针进行初始化，并且存在对象内存布局的最前面。**

 

一般分为五个区域：栈区、堆区、函数区（存放函数体等二进制代码）、全局静态区、常量区

C++中**虚函数表位于只读数据段（.rodata），也就是C++内存模型中的常量区；而虚函数则位于代码段（.text），也就是C++内存模型中的代码区。**





#### 说说C++中虚函数与纯虚函数？

1. 虚函数和纯虚函数可以定义在同一个类中，含有纯虚函数的类被称为抽象类，而只含有虚函数的类不能被称为抽象类。

2. 虚函数可以被直接使用，也可以被子类重载以后，以多态的形式调用，而纯虚函数必须在子类中实现该函数才可以使用，因为纯虚函数在基类有声明而没有定义。

3. 虚函数和纯虚函数都可以在子类中被重载，以多态的形式被调用。

4. 虚函数和纯虚函数通常存在于抽象基类之中，被继承的子类重载，目的是提供一个统一的接口。

5. 虚函数的定义形式：virtual{};纯虚函数的定义形式：virtual { } = 0;在虚函数和纯虚函数的定义中不能有static标识符，原因很简单，被static修饰的函数在编译时要求前期绑定,然而虚函数却是动态绑定，而且被两者修饰的函数生命周期也不一样。

6. 纯虚函数不可以实例化，但是可以用其派生类实例化

	虚函数的原理采用 vtable。类中含有纯虚函数时，其vtable 不完全，有个空位。即“纯虚函数在类的vftable表中对应的表项被赋值为0。也就是指向一个不存在的函数。由于编译器绝对不允许有调用一个不存在的函数的可能，所以该类不能生成对象。在它的派生类中，除非重写此函数，否则也不能生成对象。”所以纯虚函数不能实例化。

7. 纯虚函数是在基类中声明的虚函数，它要求任何派生类都要定义自己的实现方法，以实现多态性。
8.  定义纯虚函数是为了实现一个接口，用来规范派生类的行为，也即规范继承这个类的程序员必须实现这个函数。派生类仅仅只是继承函数的接口。纯虚函数的意义在于，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但基类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。





#### 构造函数或析构函数中可以调用虚函数吗

在C++中，提倡不在构造函数和析构函数中调用虚函数；构造函数和析构函数调用虚函数时都不使用动态联编，如果在构造函数或析构函数中调用虚函数，则运行的是为构造函数或析构函数自身类型定义的版本



**构造函数**

不要在构造函数中调用虚方法，从语法上讲，调用完全没有问题，但是从效果上看，往往不能达到需要的目的。

因为父类对象会在子类之前进行构造，此时子类部分的数据成员还未初始化，因此调用子类的虚函数时不安全的，故而C++不会进行动态联编

派生类对象构造期间进入基类的构造函数时，对象类型变成了基类类型，而不是派生类类型。同样，进入基类析构函数时，对象也是基类类型。

所以，虚函数始终仅仅调用基类的虚函数（如果是基类调用虚函数），不能达到多态的效果，所以放在构造函数中是没有意义的，而且往往不能达到本来想要的效果。



**析构函数**

析构函数是用来销毁一个对象的，在销毁一个对象时，先调用子类的析构函数，然后再调用基类的析构函数。所以在调用基类的析构函数时，派生类对象的数据成员已经销毁，这个时候再调用子类的虚函数没有任何意义。