# 多线程

## 问题

### 线程

C++11 创建线程方法

### 锁

C++ 11 互斥锁

C++11用过哪些锁，lockGurd和uniqueLock有什么不同

### 原子操作

atomic，它的非原子情况

atomic 怎么实现的

CAS 怎么保证原子性

volatile 关键字的作用

请简述一下atomoic内存顺序。

i++是否原子操作？并解释为什么？

原子操作是什么保证的，应该是计算机的指令级别

## 回答

### 锁

### 原子操作

#### 谈谈 atomic、volatile、register 的作用

对于volatile这个单词，权威词典有三个意思：

1. likely：可能的。这意味着被 volatile 形容的对象「有可能也有可能不」发生改变，因此我们不能对这样的对象的状态做出任何假设。
2. suddenly：突然地。这意味着被 volatile 形容的对象可能发生瞬时改变。
3. unexpectedly：不可预期地。这与 likely 相互呼应，意味着被 volatile 形容的对象可能以各种不可预期的方式和时间发生更改。

因此，volatile 其实就是告诉我们，被它修饰的对象出现任何情况都不要奇怪，我们不能对它们做任何假设。

volatile是一种类型修饰符

**在常规程序中的volatile**

```c++
volatile int *p = /* ... */;
int a, b;
a = *p;
b = *p;
```

如果忽略volatile关键字，上述代码只需要从内存读取一次就够了。因为从内存中读取一次之后，CPU 的寄存器中就已经有了这个值；把这个值直接复用就可以了。这样一来，编译器就会做优化，把两次访存的操作优化成一次。但是如果加上 volatile 关键字后，编译器对访问该变量的代码就不再进行优化，从而可以提供稳定访问，

总结： 当读取一个变量时，为提高存取速度，编译器优化时有时会先把变量读取到一个寄存器中；以后，再取变量值时，就直接从寄存器中取值。这个时候在寄存器和内存中都有我们的值，按道理来说应该是一致的，但有几种情况：

1. 当变量值在本线程里改变时，会同时把变量的新值copy到该寄存器中，以便保持一致
2. 当变量在因别的线程而改变了值，该寄存器的值不会相应改变，从而造成应用程序读取的值和实际的变量值不一致
3. 当该寄存器在因别的线程而改变了值，原变量的值不会改变，从而造成应用程序读取的值和实际的变量值不一致

volatile的意思是让编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的值

但是要知道volatile并不能真正解决多线程之间的问题。对于临界区的资源我们可以用锁机制来保护，对于非临界区的资源，如果使用 `volatile` 会禁止编译器优化相关变量，从而降低性能，所以也不建议依赖 `volatile` 在这种情况下做线程同步。

使用`std::atomic<type>` 操作是原子的，同时构建了良好的内存屏障

**多线程编程中什么情况下需要加 volatile？**

C/C++多线程编程中不要使用volatile。C++11标准中明确指出解决多线程的数据竞争问题应该使用原子操作或者互斥锁。

因为C和C++中的volatile并不是用来解决多线程竞争问题的，而是用来修饰一些因为程序不可控因素导致变化的变量，比如访问底层硬件设备的变量，以提醒编译器不要对该变量的访问擅自进行优化。

**是否可以和const一起使用？**

没问题，这俩又不冲突

C++ 中的 `volatile` 关键字，`std::atomic` 变量及手动插入内存屏障指令（Memory Barrier）均是为了避免内存访问过程中出现一些不符合预期的行为。这三者的作用有些相似之处，不过显然它们并不相同，本文就将对这三者的应用场景做一总结。

这三者应用场景的区别可以用一张表来概括：

|                | `volatile` | Memory Barrier | `atomic` |
| -------------- | ---------- | -------------- | -------- |
| 抑制编译器重排 | Yes        | Yes            | Yes      |
| 抑制编译器优化 | Yes        | No             | Yes      |
| 抑制 CPU 乱序  | No         | Yes            | Yes      |
| 保证访问原子性 | No         | No             | Yes      |

下面来具体看一下每一条。

### 抑制编译器重排

所谓编译器重排，这里是指编译器在生成目标代码的过程中交换没有依赖关系的内存访问顺序的行为。

比如以下代码：

```
*p_a = a;b = *p_b;
```

编译器**不保证**在最终生成的汇编代码中对 `p_a` 内存的写入在对 `p_b` 内存的读取之前。

如果这个顺序是有意义的，就需要用一些手段来保证编译器不会进行错误的优化。具体来说可以通过以下三种方式来实现：

- 把对应的变量声明为 `volatile` 的，C++ 标准保证对 `volatile` 变量间的访问编译器不会进行重排，不过仅仅是 `volatile` 变量之间， `volatile` 变量和其他变量间还是有可能会重排的；
- 在需要的地方手动添加合适的 Memory Barrier 指令，Memory Barrier 指令的语义保证了编译器不会进行错误的重排操作；
- 把对应变量声明为 `atomic` 的， 与 `volatile` 类似，C++ 标准也保证 `atomic` 变量间的访问编译器不会进行重排。不过 C++ 中不存在所谓的 “atomic pointer” 这种东西，如果需要对某个确定的地址进行 atomic 操作，需要靠一些技巧性的手段来实现，比如在那个地址上进行 placement new 操作强制生成一个 `atomic` 等；

**抑制编译器优化**

此处的编译器优化特指编译器不生成其认为无意义的内存访问代码的优化行为，比如如下代码：

```
void f() {  int a = 0;  for (int i = 0; i < 1000; ++i) {    a += i;  }}
```

在较高优化级别下对变量 `a` 的内存访问基本都会被优化掉，`f()` 生成的汇编代码和一个空函数基本差不多。然而如果对 `a` 循环若干次的内存访问是有意义的，则需要做一些修改来抑制编译器的此优化行为。可以把对应变量声明为 `volatile` 或 `atomic` 的来实现此目的，C++ 标准保证对 `volatile` 或 `atomic` 内存的访问肯定会发生，不会被优化掉。

不过需要注意的是，这时候手动添加内存屏障指令是没有意义的，在上述代码的 `for` 循环中加入 `mfence` 指令后，仅仅是让循环没有被优化掉，然而每次循环中对变量 `a` 的赋值依然会被优化掉，结果就是连续执行了 1000 次 `mfence`。

**抑制 CPU 乱序**

上面说到了编译器重排，那没有了编译器重排内存访问就会严格按照我们代码中的顺序执行了么？非也！现代 CPU 中的诸多特性均会影响这一行为。对于不同架构的 CPU 来说，其保证的内存存储模型是不一样的，比如 x86_64 就是所谓的 TSO（完全存储定序）模型，而很多 ARM 则是 RMO（宽松存储模型）。再加上多核间 Cache 一致性问题，多线程编程时会面临更多的挑战。

为了解决这些问题，从根本上来说只有通过插入所谓的 Memory Barrier 内存屏障指令来解决，这些指令会使得 CPU 保证特定的内存访问序及内存写入操作在多核间的可见性。然而由于不同处理器架构间的内存模型和具体 Memory Barrier 指令均不相同，需要在什么位置添加哪条指令并不具有通用性，因此 C++ 11 在此基础上做了一层抽象，引入了 `atomic` 类型及 Memory Order 的概念，有助于写出更通用的代码。从本质上看就是靠编译器来根据代码中指定的高层次 Memory Order 来自动选择是否需要插入特定处理器架构上低层次的内存屏障指令。

关于 Memory Order，内存模型，内存屏障等东西的原理和具体使用方法网上已经有很多写得不错的文章了，可以参考文末的几篇参考资料。

**保证访问原子性**

所谓访问原子性就是 Read，Write 操作是否存在中间状态，具体如何实现原子性的访问与处理器指令集有很大关系，如果处理器本身就支持某些原子操作指令，如 Atomic Store， Atomic Load，Atomic Fetch Add，Atomic Compare And Swap（CAS）等，那只需要在代码生成时选择合适的指令即可，否则需要依赖锁来实现。C++ 中提供的可移植通用方法就是 `std::atomic`，`volatile` 及 Memory Barrier 均与此完全无关。

**总结**

从上面的比较中可以看出，`volatile`，`atomic` 及 Memory Barrier 的适用范围还是比较好区分的。

- 如果需要原子性的访问支持，只能选择 `atomic`；
- 如果仅仅只是需要保证内存访问不会被编译器优化掉，优先考虑 `volatile`；
- 如果需要保证 Memory Order，也优先考虑 `atomic`，只有当不需要保证原子性，而且很明确要在哪插入内存屏障时才考虑手动插入 Memory Barrier。

volatile是作用在单线程下，针对特定内存使用的。

atomic是c++11提供的原子类操作

volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。**遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。**声明时语法：int volatile vInt; 当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。

volatile用在如下的几个地方：

- 中断服务程序中修改的供其它程序检测的变量需要加volatile；
- 多任务环境下各任务间共享的标志应该加volatile；
- 存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义；

- atomic可用在多线程中，对小数据进行原子操作，是安全的
- volatile用于特殊内存防止编译器级别的优化，atomic用于普通内存，优化没有副作用，如果是特殊内存就用volatile,如果并且是多线程，可以叠加atomic使用
- 可以搭配一起使用，atomic并不能取代volatile的作用，volatile也没有atomic的功能

register关键字：这个关键字请求编译器尽可能的将变量存在CPU内部寄存器中，而不是通过内存寻址访问，以提高效率

#### **请简述一下atomoic内存顺序**

有六个内存顺序选项可应用于对原子类型的操作：

1. memory_order_relaxed：在原子类型上的操作以自由序列执行，没有任何同步关系，仅对此操作要求原子性。
2. memory_order_consume：memory_order_consume只会对其标识的对象保证该对象存储先行于那些需要加载该对象的操作。
3. memory_order_acquire：使用memory_order_acquire的原子操作，当前线程的读写操作都不能重排到此操作之前。
4. memory_order_release：使用memory_order_release的原子操作，当前线程的读写操作都不能重排到此操作后。
5. memory_order_acq_rel：memory_order_acq_rel在此内存顺序的读-改-写操作既是获得加载又是释放操作。没有操作能够从此操作之后被重排到此操作之前，也没有操作能够从此操作之前被重排到此操作之后。
6. memory_order_seq_cst：memory_order_seq_cst比std::memory_order_acq_rel更为严格。memory_order_seq_cst不仅是一个"获取释放"内存顺序，它还会对所有拥有此标签的内存操作建立一个单独全序。

除非你为特定的操作指定一个顺序选项，否则内存顺序选项对于所有原子类型默认都是memory_order_seq_cst。
