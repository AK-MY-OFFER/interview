# 编译链接

## 问题

* 说说include头文件的顺序以及双引号""和尖括号<>的区别
* 简述C++从代码到可执行二进制文件的过程
* 动态链接所有的段都只是一份吗（个人认为是只有代码段是一份的， 因为[数据](https://www.nowcoder.com/jump/super-jump/word?word=数据)的话对于每个进程是私有的，不共享）
* 问我静态链接和动态链接什么时候，动态链接不会有内存消耗的优势
* O0、O1、O2、O3 优化
* 什么是 gcc ？工作流程是什么？
* 你知道 Debug 和 Release 的区别是什么吗？

## 回答

### 说说include头文件的顺序以及双引号""和尖括号<>的区别

（1）尖括号<>的头文件是**系统文件**，双引号""的头文件是**自定义文件**。

（2）编译器预处理阶段查找头文件的路径不一样。

查找路径：

（1）使用尖括号<>的头文件的查找路径：编译器设置的头文件路径-->系统变量。

（2）使用双引号""的头文件的查找路径：当前头文件目录-->编译器设置的头文件路径-->系统变量。



### 简述C++从代码到可执行二进制文件的过程

C++和C语言类似，一个C++程序从源码到执行文件，有四个过程，**预编译、编译、汇编、链接**。

#### **预编译：**

（1） 将所有的#define删除，并且展开所有的宏定义

（2） 处理所有的条件预编译指令，如#if、#ifdef

（3） 处理#include预编译指令，将被包含的文件插入到该预编译指令的位置。

（4） 过滤所有的注释

（5） 添加行号和文件名标识。

#### **编译：**

把预编译之后生成的xxx.i或xxx.ii文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应 的汇编代码文件。

1. 词法分析：利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字符序列分 割成一系列的记号。
2. 语法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的 语法树是一种以表达式为节点的树。
3. 语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进 行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定 的语义。
4. 优化：源代码级别的一个优化过程。
5. 目标代码生成：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——汇编语言 表示。
6. 目标代码优化：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移 来替代乘法运算、删除多余的指令等。



#### **汇编：**

这个过程主要是将汇编代码转变成机器可以执行的指令。将汇编代码转变成机器可以执行的指令(机器码文件)。 汇编器的汇编过程相对于编译器来说更简单，没 有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过 来，汇编过程有汇编器as完成。经汇编之后，产生目标文件(与可执行文件格式几乎一样)xxx.o(Windows 下)、xxx.obj(Linux下)。



#### **链接：**（还要细化具体过程）

将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。

链接分为静态链接和动态链接。



**静态链接**

静态链接，是在链接的时候就已经把要调用的函数或者过程链接到了生成的可执行文件中，就算你在去把静态库删除也不会影响可执行程序的执行；生成的静态链接库，Windows下以.lib为后缀，Linux下以.a为后缀。

函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库 中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。

![img](https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.4.2/202102/微信截图_20210201114618.png)

静态链接器以一组可重定位目标文件为输入，生成一个完全链接的可执行目标文件作为输出。链接器主要完成以下两个任务：

- 符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号引用与一个符号定义关联起来。
- 重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存位置。



目标文件

- 可执行目标文件：可以直接在内存中执行；
- 可重定位目标文件：可与其它可重定位目标文件在链接阶段合并，创建一个可执行目标文件；
- 共享目标文件：这是一种特殊的可重定位目标文件，可以在运行时被动态加载进内存并链接；



优点

* 运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西， 在执行的时候运行速度快
* 静态编译，编译器在编译可执行文件时，把要用到的对应动态链接库中的部分提取出来，连接到可执行文件中去，使可执行文件在运行时不需要依赖于动态链接库

缺点

* 空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个 目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本（对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。）

* 更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序

	



**动态链接**

动态链接，是在链接的时候没有把调用的函数代码链接进去，而是在执行的过程中，再去找要链接的函数，生成的可执行文件中没有函数代码，只包含函数的重定位信息，所以当你删除动态库时，可执行程序就不能运行。生成的动态链接库，Windows下以.dll为后缀，Linux下以.so为后缀。

动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形 成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。

![img](https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.4.2/202102/微信截图_20210201115700.png)

优点

* 更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运 行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标
* 共享库：执行文件本身的体积。就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多分，副 本，而是这多个程序在执行时共享同一份副本
* 动态编译：加快了编译速度，节省了系统资源

缺点

* 性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损 失
* 哪怕是很简单的程序，只用到了链接库的一两条命令，也需要附带一个相对庞大的链接库
* 如果其他计算机上没有安装对应的运行库，则用动态编译的可执行文件就不能运行



### O0、O1、O2、O3优化

**-O0**

不做任何优化，这是默认的编译选项。

**-O1**

主要对代码的分支、常量以及表达式进行优化。会减小代码的尺寸，缩短执行周期啥的

 -floop-optimize：执行循环优化,将常量表达式从循环中移除，简化判断循环的条件，并且optionally do strength-reduction，或者将循环打开等。在大型复杂的循环中，这种优化比较显著。

**-O2**

O2优化再打开O1优化的前提下，尝试更多的寄存器级的优化以及指令级的优化，它会在编译期间占用更多的内存和编译时间。

所以一般来说可以直接开-O2的优化等级，

**-O3**

 在O2的基础上进行更多的优化，例如使用伪寄存器网络，普通函数的内联，以及针对循环的更多优化。

这个好像不推荐，因为会增加编译失败和程序不可预知的一些行为，不建议使用



### 什么是 gcc ？工作流程是什么？

#### 什么是gcc

**gcc的全称是GNU Compiler Collection，它是一个能够编译多种语言的编译器。**

最开始gcc是作为C语言的编译器（GNU C Compiler），现在除了c语言，还支持C++、java、Pascal等语言。

#### gcc工作流程

* 预处理（--E）
  * 宏替换
  * 头文件展开
  * 去掉注释
  * .c文件变成了.i文件（本质上还是.c文件，只不过#include中的程序给链接进去）
* 编译（--S）
  * gcc调用不同语言的编译器
  * .i文件编程.s（汇编文件）
  * 生成汇编文件

* 汇编（-c）
  * .s文件转化成.o文件
  * 翻译成机器语言指令
  * 二进制文件
* 链接
  * .o文件变成可执行文件，一般不加后缀

> ![img](https://cdn.jsdelivr.net/gh/luogou/cloudimg/data/202201241320667.jpeg)
>
> **预处理**实际上是将头文件、宏进行展开。
>
> **编译阶段**gcc调用不同语言的编译器。gcc实际上是个工具链，在编译程序的过程中调用不同的工具。
>
> **汇编阶段**gcc调用汇编器进行汇编。汇编语言是一种低级语言，在不同的设备中对应着不同的机器语言指令，一种汇编语言专用于某种计算机体系结构，可移植性比较差。通过相应的汇编程序可以将汇编语言转换成可执行的机器代码这一过程叫做汇编过程。汇编器生成的是可重定位的目标文件，在源程序中地址是从0开始的，这是一个相对地址，而程序真正在内存中运行时的地址肯定不是从0开始的，而且在编写源代码的时候也不能知道程序的绝对地址，所以**重定位**能够将源代码的代码、变量等定位为内存具体地址。
>
> **链接过程**会将程序所需要的目标文件进行链接成可执行文件。

#### gcc常用参数

* -v/--version：查看gcc的版本
* -I：编译的时候指定头文件路径，不然头文件找不到
* -c：将汇编文件转换成二进制文件，得到.o文件
* -g：gdb调试的时候需要加
* -D：编译的时候指定一个宏（调试代码的时候需要使用例如printf函数，但是这种函数太多了对程序性能有影响，因此如果没有宏，则#ifdefine的内容不起作用）
* -wall：添加警告信息
* -On：-O是优化代码，n是优化级别：1，2，3





### 你知道 Debug 和 Release 的区别是什么吗？

Debug 版本的存在是为了方便程序员开发和调试，性能和体积不是它的重点；Release 版本是最终交给用户的程序，性能和体积是需要重点优化的两个方面。

在开发过程中，我们一般使用 Debug 版本，只有等到开发完成，确认没有任何 Bug 之后，希望交给用户时再生成 Release 版本。

**Debug 版本**

Debug 是“调试”的意思，Debug 版本就是为调试而生的，编译器在生成 Debug 版本的程序时会加入调试辅助信息，并且很少会进行优化，程序还是“原汁原味”的。

Debug 调试，你在程序中设置了断点，为什么vs.net知道在那里要停下来，当你把鼠标移到某个变量上，vs.net就会显示它当时的值？
因为编译器在代码中添加了许多调试需要的代码，可以让vs.net得到，返回给你。这些代码当然是要占用空间和时间的，在你的程序调试完了后，可以正确运行了。完全可以去掉这些代码，这时候就应该用Release模式了。

**Release 版本**

Release 是“发行”的意思，Release 版本就是最终交给用户的程序，编译器会使尽浑身解数对它进行优化，以提高执行效率，虽然最终的运行结果仍然是我们期望的，但底层的执行流程可能已经改变了。

编译器还会尽量降低 Release 版本的体积，把没用的数据一律剔除，包括调试信息。最终，Release 版本是一个小巧精悍、非常纯粹、为用户而生的程序。Release代码更小,执行更快,编译更严格,更慢

